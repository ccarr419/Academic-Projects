# CSC 343, Fall 2016, STUDENT NAME:
# rr_bf_swap.stm implements a preemptive round-robin CPU scheduler
# and no process swapping to the swap disk when the processor is out of memory.
# A process does release memory when scheduling io or terminating.
# It wakes up *one* swapped-out processes when releasing memory.
# This program uses best fit to organize the process physical memory.
# A process that needs memory goes into a processor.waitMemQ
# where it waits until a process does io or terminates, releasing memory.
# The implication of releasing memory before io signifies double buffered io.

machine processor {
    # Use this machine in all of your files in assignment 3 to start processes.
    # It starts 24 processes, one every tick. Each process starts life with
    # thread 0, spawning no additional threads. Fast IO unit N-1 is reserved
    # to be the swap device. IO unit -1 is the slow device (terminal), and
    # 0..N-2 are available for io() calls.
    processesToGo = 24, tid = -1, pid = -1 ;
    start init, state makingProcesses, accept doneMakingThreads ;
    init -> makingProcesses init()[]/@
        # CPU scheduling queue:
        processor.readyq = Queue(ispriority=False);
        # Two gig of available memory, initially all free, starts at phyaddr 0.
        processor.physicalMemory = 2147483648 ;
        # Each entry in this table is a (LIMIT, BASE) pair, with values giving
        # (SIZE, START_ADDRESS) of a region in physical memory. As memory gets
        # allocated and freed by processes, this initial region gets chopped
        # up into multiple smaller regions and the merged where possible
        # when freeing. See macros and lambda functions in the thread state
        # machine for the code the manages the processor.freeregions and
        # pcb.relocationRegister.
        processor.freeregions = [(processor.physicalMemory, 0)];
        # The waitMemQ is the Queue where processes wait until they get memory.
        processor.waitMemQ = Queue(ispriority=False);
        processesToGo -= 1 ; fork()@
    makingProcesses -> makingProcesses fork(pid, tid)[@processesToGo > 0@]/@
        processesToGo -= 1 ; fork()@
    makingProcesses -> doneMakingThreads fork(pid, tid)[@processesToGo == 0@]/
}

# This assignment uses round-robin CPU scheduling with 50% IO-bound and
# 50% CPU-bound single-threaded processes.
machine thread {
    quantum = 125, machineid = -1, pid = -1, tid = -1, iobound = @False@,
        # Traverse the main state loop loopLimit times, then terminate.
        loopCount = 0,  loopLimit = 10,
        cpuburst = -1, tickstorun = -1, tickstodefer = -1,
        swapdevice = -2, iodevice = -2, findcost = -1, putcost = -1,
        cpuBurstSum = 0, cpuBurstSwap = 500,
            lifeTimeSwap = 10000,
        # findFreeSlot uses serial search for first fit, sort to get best fit
        # requiredAmount is the process memory size in bytes.
        # index is 0 on the initial call, needed for recursion.
        # freeregionsList is typically processor.freeregions.
        # findFreeSlot argument needed for recursive looping.
        findFreeSlot = @lambda requiredAmount, index, freeregionsList,
                findFreeSlot :
            -1 if (index >= len(freeregionsList))
                else (index if freeregionsList[index][0] >= requiredAmount
                    else findFreeSlot(requiredAmount, index+1,
                        freeregionsList, findFreeSlot))@,
        # costFirstFit estimates the O(n) cost of search for first fit.
        # index is the value returned by findFreeSlot, may be -1.
        # freeregionsList is typically processor.freeregions.
        costFirstFit = @lambda index, freeregionsList : (index + 1)
            if index >= 0 else (len(freeregionsList) + 1)@,
        # costBestFit estimates the O(log(n)) cost of search for best fit
        #   in a balanced binary tree or similar data structure.
        # index is the value returned by findFreeSlot, may be -1.
        # freeregionsList is typically processor.freeregions.
        # math is a reference to the Python math module
        costBestFit = @lambda index, freeregionsList, math : int(math.ceil(
            math.log(index+1) / math.log(2))) if index >= 0
                else int(math.ceil(math.log(len(freeregionsList))
                    / math.log(2)))@,
        # mergeRegions merges adjacent free regions of processor.freeregions.
        # mergeRegions REQUIRES an ascending numeric sort on the
        # second field of processor.freeregions, which is the base address
        # of each region, BEFORE making the call to mergeRegions.
        # pair must be an empty tuple () on the initial call.
        # headlist must be an empty list [] on the initial call.
        # taillist is typically processor.freeregions.
        # mergeRegions argument needed for recursive looping.
        mergeRegions = @lambda pair, headlist, taillist, mergeRegions :
            # pair sits behind the headlist and in front of taillist.
            headlist if not (pair or taillist)
                else (headlist + [pair]) if not taillist
                # Shift first entry of taillist into the pair position:
                else mergeRegions(taillist[0],headlist,taillist[1:],
                        mergeRegions) if not pair
                # Merge adjacent pair and front of tailist into pair.
                else mergeRegions((pair[0]+taillist[0][0],pair[1]),
                        headlist,taillist[1:],mergeRegions)
                            if ((pair[0]+pair[1]) == taillist[0][1])
                # Not adjacent, shift pair into headlist and continue.
                else mergeRegions(taillist[0],headlist+[pair],
                                taillist[1:],mergeRegions)
            @;
    start init, state checkIfMemory, state scheduling,
        state ready, state waitForMemory, state running, state waiting,
        state releasing, state rescheduling, accept terminated ;
    # takeMemory is a utility used by getFirstFit and getBestFit.
    macro takeMemory @
        msg("DEBUG_TKM1|" + str(pcb.relocationRegister) + "|"
            + str(processor.freeregions) + "|");
        pcb.relocationRegister = processor.freeregions[freeslot]
            if freeslot > -1 else None;
        remainder = pcb.relocationRegister[0] - pcb.logicalMemorySize
            if freeslot > -1 else 0 ;
        # Remove a completely-consumed region from memory pool:
        if freeslot > -1
                and remainder == 0: del processor.freeregions[freeslot];
        # Update the base address to the start of the leftover subregion:
        if freeslot > -1
                and remainder > 0: processor.freeregions[freeslot]
                    =  (remainder, pcb.relocationRegister[1]
                        + pcb.logicalMemorySize);
        # The following needed if there was a remainder:
        pcb.relocationRegister = (pcb.logicalMemorySize,
            pcb.relocationRegister[1]) if freeslot > -1 else None;
        msg("DEBUG_TKM2|" + str(pcb.relocationRegister) + "|"
            + str(processor.freeregions) + "|");
        @
    # Do a serial search, set variables freeslot and findcost.
    macro getFirstFit @
        freeslot = findFreeSlot(pcb.logicalMemorySize, 0,
            processor.freeregions, findFreeSlot);
        findcost = costFirstFit(freeslot, processor.freeregions);
        takeMemory ;
        @
    # Do a simulated O(log(n)) search, set variables freeslot and findcost.
    macro getBestFit @
        # Sort on region size in ascending order.
        processor.freeregions.sort();
        freeslot = findFreeSlot(pcb.logicalMemorySize, 0,
            processor.freeregions, findFreeSlot);
        # Use -1, not freeslot, to simulate searching balanaced tree to leaf.
        findcost = costBestFit(-1, processor.freeregions, math);
        takeMemory ;
        @
    # Merge the pcb.relocationRegister back into processor.freeregions.
    # putFirstFit and putBestFit use putBackRegion.
    macro putBackRegion @
        msg("DEBUG_PBR1|" + str(pcb.relocationRegister) + "|"
            + str(processor.freeregions) + "|");
        processor.freeregions.append(pcb.relocationRegister);
        pcb.relocationRegister = None ;
        # Sort on the base address field of each region.
        processor.freeregions.sort(key = lambda element : element[1]);
        processor.freeregions = mergeRegions((), [], processor.freeregions,
            mergeRegions);
        msg("DEBUG_PBR2|" + str(pcb.relocationRegister) + "|"
            + str(processor.freeregions) + "|");
        @
    macro putFirstFit @
        putBackRegion ;
        putcost = 1 ;
        @
    macro putBestFit @
        putBackRegion ;
        putcost = costBestFit(len(processor.freeregions),processor.freeregions,
            math);
        @

    # Initialize variables used by this single-threaded process:
    init -> checkIfMemory init()[]/@machineid, pid, tid = getid();
        iobound = True if ((pid % 2) == 1) else False ;
        # ^^^ The odd pids are IO bound. The others (50%) are CPU bound.
        swapdevice = len(processor.fastio)-1 ;
        # The range of process sizes drives contention for memory.
        # Each process averages (1/16 + 1/2) / 2 = .28125 of physical memory,
        # so we'd expect 3 to 4 processes to for into memory at one time,
        # and never fewer than 2 will fit at one time. See processesToGo
        # in the processor STM above.
        pcb.logicalMemorySize = sample(int(processor.physicalMemory/16),
            int(processor.physicalMemory/2), 'uniform');
        # pcb.relocationRegister will get a piece of processor.freeregions.
        # Its value when memory is allocated is (SIZE, BASE), else None.
        pcb.relocationRegister = None ;
        cpuburst = sample(1, 250, 'exponential', 25) if iobound
            else sample(100, 1100, 'revexponential', 1000);
        cpuBurstSum += cpuburst ;
        tickstorun = min(cpuburst, quantum);
        tickstodefer = cpuburst - tickstorun;
        # Set variables freeslot and findcost:
        getBestFit ;
        cpu(findcost)@
    # The next two transitions trigger on completion of cpu(TICKS) call.
    # Following two are same except that they trigger on io(DEV) completion.
    checkIfMemory -> scheduling cpu()[@pcb.relocationRegister != None@]/@
        yieldcpu()@
    checkIfMemory -> waitForMemory cpu()[@pcb.relocationRegister == None@]/@
        processor.waitMemQ.enq(thread);
        waitForEvent('memoryReady', False)@
    checkIfMemory -> scheduling io()[@pcb.relocationRegister != None@]/@
        yieldcpu()@
    checkIfMemory -> waitForMemory io()[@pcb.relocationRegister == None@]/@
        processor.waitMemQ.enq(thread);
        waitForEvent('memoryReady', False)@
    waitForMemory -> checkIfMemory memoryReady()[]/@
        # Set variables freeslot and findcost:
        getBestFit ;
        # Charge more expensive io operation if we are actually swapping in.
        io(swapdevice) if (pcb.relocationRegister)
            else cpu(findcost)@
    scheduling -> running yieldcpu()[@processor.contextsFree > 0@]/@
        processor.contextsFree -= 1 ;
        cpu(tickstorun)@
    scheduling -> ready yieldcpu()[@processor.contextsFree == 0@]/@
        processor.readyq.enq(thread);
        waitForEvent('contextReady', False)@
    ready -> scheduling contextReady()[]/@yieldcpu()@
    # ^^^ Do not set cpuburst; they have not all been used.
    running -> scheduling cpu()[@tickstodefer > 0@]/@
        processor.contextsFree += 1 ;
        signalEvent(processor.readyq.deq(), 'contextReady')
            if len(processor.readyq) > 0 else noop();
        tickstorun = min(tickstodefer, quantum);
        tickstodefer = tickstodefer - tickstorun;
        yieldcpu()@
    running -> rescheduling cpu()[@tickstodefer  < 1@]/@
        processor.contextsFree += 1 ;
        signalEvent(processor.readyq.deq(), 'contextReady')
            if len(processor.readyq) > 0 else noop();
        yieldcpu()@
    rescheduling -> terminated yieldcpu()[@(loopCount+1) >= loopLimit@]/@
        loopCount += 1 ;
        # Release held memory and signal the next waiting thread if any.
        # We do not need to write to swapdevice on termination.
        putBestFit ;
        # Wake up all waiting processes.
        if len(processor.waitMemQ):
            signalEvent(processor.waitMemQ.deq(), 'memoryReady');
        msg("DEBUG END|" + str(cpuBurstSum) + "|");
        cpu(putcost)@
    rescheduling -> releasing yieldcpu()[@(loopCount+1) < loopLimit@]/@
        # Swap out process memory during IO, implying double buffering.
        # Release held memory and signal the next waiting thread if any.
        loopCount += 1 ;
        putBestFit ;
        if len(processor.waitMemQ):
            signalEvent(processor.waitMemQ.deq(), 'memoryReady');
        io(swapdevice)@
    releasing -> waiting io()[]/@
        # Swap out has completed, initiate double-buffered IO.
        # Pick an iodevice of -1 (process terminal) or one of fastio devices.
        # Do not use the swapdevice at len(processor.fastio)-1.
        iodevice = sample(-1, len(processor.fastio)-2, 'uniform');
        io(iodevice)@
    waiting -> checkIfMemory io()[]/@
        cpuburst = sample(1, 250, 'exponential', 25) if iobound
            else sample(100, 1100, 'revexponential', 1000);
        cpuBurstSum += cpuburst ;
        tickstorun = min(cpuburst, quantum);
        tickstodefer = cpuburst - tickstorun;
        # Set variables freeslot and findcost:
        getBestFit ;
        # Charge more expensive io operation if we are actually swapping in.
        io(swapdevice) if (pcb.relocationRegister)
            else cpu(findcost)@
}

processor
