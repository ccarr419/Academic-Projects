\hypertarget{p2_8cpp}{
\section{p2.cpp File Reference}
\label{p2_8cpp}\index{p2.cpp@{p2.cpp}}
}


This project aims to replicate a client/server environment by using concurrent processes and IPC mechanisms. The client and server will each have their separate process as well as their own read and write ends from two separate pipes. To start, two pipes are created and then a second process is forked to separate the client and server. The client is the parent process and the server is the child. Each process will close the pipe ends that they will never use. The server will redirect its pipe ends to stdin and stdout and then exec while the client will send the file descriptors for the pipe ends being used as arguments in the exec function. All errors with pipes, forks, and execs are being accounted for with the use of perror (stderr).  
{\ttfamily \#include $<$iostream$>$}\par
{\ttfamily \#include $<$cstdio$>$}\par
{\ttfamily \#include $<$sstream$>$}\par
{\ttfamily \#include $<$sys/wait.h$>$}\par
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
const char $\ast$ \hyperlink{p2_8cpp_a815a7c06d22e389b397b9520e6022a87}{makeExec} (const char $\ast$)
\begin{DoxyCompactList}\small\item\em This function takes a single argument of const char$\ast$ and returns a similar const char$\ast$ with the exception being './' precedes the argument value. This is necessary for proper execution in a Unix environment. Without this addition to an executable name, every exec function will fail. \item\end{DoxyCompactList}\item 
const char $\ast$ \hyperlink{p2_8cpp_a885489e77b93121eada5ba44d710e74e}{toCString} (int)
\begin{DoxyCompactList}\small\item\em This function takes a single argument of int and returns the equivalent in const char$\ast$. This is necessary in order to pass the int value as a argument in any exec function. In this project it is used to pass pipe ends to a process so that process can send and receive information through a single or numerous pipes. \item\end{DoxyCompactList}\item 
void \hyperlink{p2_8cpp_a16c595425376e45620a0c627b6585cb4}{parentProcess} (int\mbox{[}$\,$\mbox{]}, int\mbox{[}$\,$\mbox{]})
\begin{DoxyCompactList}\small\item\em This function will be called by the parent process after the fork. It will close any unused pipe ends in the two given arguments, create any necessary arguments to pass through exec and then finally call exec thus running the client executable. \item\end{DoxyCompactList}\item 
void \hyperlink{p2_8cpp_a4a3e6890f6e9755839ccfc113da2b697}{childProcess} (int\mbox{[}$\,$\mbox{]}, int\mbox{[}$\,$\mbox{]})
\begin{DoxyCompactList}\small\item\em This function will be called by the child process after the fork. It will close any unused pipe ends in the two given arguments, create any necessary arguments to pass through exec and then finally call exec thus running the server executable. \item\end{DoxyCompactList}\item 
int \hyperlink{p2_8cpp_ae66f6b31b5ad750f1fe042a706a4e3d4}{main} ()
\end{DoxyCompactItemize}


\subsection{Detailed Description}


\subsection{Function Documentation}
\hypertarget{p2_8cpp_a4a3e6890f6e9755839ccfc113da2b697}{
\index{p2.cpp@{p2.cpp}!childProcess@{childProcess}}
\index{childProcess@{childProcess}!p2.cpp@{p2.cpp}}
\subsubsection[{childProcess}]{\setlength{\rightskip}{0pt plus 5cm}void childProcess (int {\em c2s}\mbox{[}$\,$\mbox{]}, \/  int {\em s2c}\mbox{[}$\,$\mbox{]})}}
\label{p2_8cpp_a4a3e6890f6e9755839ccfc113da2b697}
$\ast$ Function Name: childProcess Function Type: mutator Parameters: int\mbox{[}\mbox{]} -\/ import/export -\/ pipe 1 int\mbox{[}\mbox{]} -\/ import/export -\/ pipe 2 Return Value: void

The child process will implement the server side of the project. First all usused pipe ends will be closed by using the array parameters given. Then the pipe ends that will be used will be redirected towards stdin and stdout since the server will only communicate with the client. The redirection is done by the dup2 function. Lastly the server executable will be transformed into the correct format so exec can use it properly. 


\begin{DoxyCode}
191                                         {
192         const char *server;
193         //Close unused pipe ends
194         close(s2c[0]);          
195         close(c2s[1]);
196         dup2(c2s[0], 0); //Redirect to stdin
197         dup2(s2c[1], 1); //Redirect to stdout
198         server = makeExec("server"); //Create argument for exec
199         execlp(server, NULL);
200 }
\end{DoxyCode}
\hypertarget{p2_8cpp_ae66f6b31b5ad750f1fe042a706a4e3d4}{
\index{p2.cpp@{p2.cpp}!main@{main}}
\index{main@{main}!p2.cpp@{p2.cpp}}
\subsubsection[{main}]{\setlength{\rightskip}{0pt plus 5cm}int main ()}}
\label{p2_8cpp_ae66f6b31b5ad750f1fe042a706a4e3d4}



\begin{DoxyCode}
95            {
96         pid_t isParent; //Easily differentiate between child and parent process
97         //File descriptors to use for pipe creation
98         int client2Server_fd[2];
99         int server2Client_fd[2];
100         
101         //Variables to hold arguments for exec functions
102         const char *client, *server, *cRead, *cWrite;   
103         
104         //Create the client to server pipe
105         //Client will have the write end and the server will have the read end
106         if(pipe(client2Server_fd) == -1) {
107                 perror("Pipe Error -- Client to Server pipe could not be created\
      n");
108                 return 0;
109         }
110         
111         //Create the server to client pipe
112         //Server will have the write end and the client will have the read end
113         if(pipe(server2Client_fd) == -1) {
114                 perror("Pipe Error -- Server to Client pipe could not be created\
      n");
115                 return 0;
116         }
117         
118         //Fork a second process and get the pid of both processes to easily
119         //determine if it is the child or the parent
120         isParent = fork();
121         if(isParent) {  
122                 parentProcess(client2Server_fd, server2Client_fd);
123                 perror("Parent exec failed\n"); //Should only fire if exec failed
      
124         }
125         //If the process is the child
126         else if(isParent == 0) {
127                 childProcess(client2Server_fd, server2Client_fd);
128                 perror("Child exec failed\n"); //Should only fire if exec failed
129         }
130         //If it is not the parent or the child then the fork failed
131         else {
132                 perror("Fork Error -- could not fork another process\n");
133         }
134         
135         return 0;
136 }
\end{DoxyCode}
\hypertarget{p2_8cpp_a815a7c06d22e389b397b9520e6022a87}{
\index{p2.cpp@{p2.cpp}!makeExec@{makeExec}}
\index{makeExec@{makeExec}!p2.cpp@{p2.cpp}}
\subsubsection[{makeExec}]{\setlength{\rightskip}{0pt plus 5cm}const char $\ast$ makeExec (const char $\ast$ {\em exe})}}
\label{p2_8cpp_a815a7c06d22e389b397b9520e6022a87}
$\ast$ Function Name: makeExec Function Type: facilitator Parameters: const char$\ast$ -\/ import only -\/ executable name Return Value: const char$\ast$ -\/ ready to be used argument for exec

makeExec takes a single const char$\ast$ argument named exec and concatenates with the string value \char`\"{}./\char`\"{} It then returns the cstring equivalent of that concatenation. i.e the result will look like this: \char`\"{}./exe\char`\"{} This function should be used with every exec function to ensure that it works properly in a Unix environment. 


\begin{DoxyCode}
144 {
145         string suf = "./"; //Unix's way of opening an executable
146         string tempStr = suf + exe;
147         return tempStr.c_str();
148 }
\end{DoxyCode}
\hypertarget{p2_8cpp_a16c595425376e45620a0c627b6585cb4}{
\index{p2.cpp@{p2.cpp}!parentProcess@{parentProcess}}
\index{parentProcess@{parentProcess}!p2.cpp@{p2.cpp}}
\subsubsection[{parentProcess}]{\setlength{\rightskip}{0pt plus 5cm}void parentProcess (int {\em c2s}\mbox{[}$\,$\mbox{]}, \/  int {\em s2c}\mbox{[}$\,$\mbox{]})}}
\label{p2_8cpp_a16c595425376e45620a0c627b6585cb4}
$\ast$ Function Name: parentProcess Function Type: mutator Parameters: int\mbox{[}\mbox{]} -\/ import/export -\/ pipe 1 int\mbox{[}\mbox{]} -\/ import/export -\/ pipe 2 Return Value: void

The parent process will implement the client side of the project. First all unused pipe ends will be closed by using the array parameters given. Then the client executable will be be transformed into the correct format so exec can use it properly. Lastly the pipe ends that will be used will be transformed into const char$\ast$ so they can be used as arguments in the exec. 


\begin{DoxyCode}
171                                          {
172         const char *client, *cRead, *cWrite;
173         //Close unused pipe ends
174         close(c2s[0]);
175         close(s2c[1]);
176         //Create arguments for exec
177         client = makeExec("client");            
178         cRead = toCString(s2c[0]);
179         cWrite = toCString(c2s[1]);
180         //Exec to client process
181         execlp(client, cRead, cWrite, NULL);
182 }
\end{DoxyCode}
\hypertarget{p2_8cpp_a885489e77b93121eada5ba44d710e74e}{
\index{p2.cpp@{p2.cpp}!toCString@{toCString}}
\index{toCString@{toCString}!p2.cpp@{p2.cpp}}
\subsubsection[{toCString}]{\setlength{\rightskip}{0pt plus 5cm}const char $\ast$ toCString (int {\em num})}}
\label{p2_8cpp_a885489e77b93121eada5ba44d710e74e}
$\ast$ Function Name: toCString Function Type: facilitator Parameters: int -\/ import only -\/ number to become cstring Return Value: const char$\ast$ -\/ ready to be used argument for exec

toCString takes a single int argument which is to be turned into a const char $\ast$ value. Stringstream will be used to correctly transfer the int value into a cstring. The int value is put into the stringstream using stream insertion. A temporary string will then hold the string equivalent of the string stream. The temporary string is then turned into the cstring equivalent and returned. 


\begin{DoxyCode}
158 {
159         stringstream sstr;
160         sstr << num;
161         string tempStr = sstr.str();
162         return tempStr.c_str();
163 }
\end{DoxyCode}
