# Name:			Christian Carreras
# File:			countMutex2.stm
# Date:			10/17/2016
# Course:		CSC343 Kutztown University
# Professor:	Dr. Parson
# Assignment:	2
# About:		This file imitates a state machine where mutex locks are used to
#				prevent multiple threads from modifying the same data asynchronously. 
#				Two threads are trying to fetch memory into a register, do a
#				mathematical function on the register, and store the register back
#				into memory. To synchronize the threads this will be done
#				by the use of a mutex lock. Mutex locks will ensure
#				that only one thread will compute the critical section code
#				at a time while the others wait until it is finished.
#				A waiting thread will transition into a waiting state and be placed
#				in a queue to ensure a First-In First-Out (FIFO/Fair) scenario.
#				The front waiting thread in the queue will transition back once 
#				an event is triggered by the lock being unlocked again.

machine processor {
    # STUDENT: Do not change the processor state machine.
    # Use this machine in all of your files in assignment 2 to fork
    # 1 process that runs many threads.
    start init, accept processorDone ;
    init -> processorDone init()[]/@
        fork()@
}

# STUDENT work goes into machine thread according to the handout.
# Add documentation comments for the code that you write!!!
machine thread {
    # You probably need to create additional variables.
    # When the iterations to the transition to go into the terminated state
    # increment loopCount to >= loopLimit, go to terminated.
    loopCount = 0, loopLimit = 10, sumRegister = 0, differenceRegister = 0,
        threadCount = 2,
        # Adjust loopGrandTotal to loopLimit * threadCount in init ->.
        loopGrandTotal = 0 ;
    start init, state initThreads,
        state fetchSum, state addSum, state storeSum,
        state fetchDifference, state addDifference, state storeDifference,
        state lockSum, state unlockSum,
		state lockSumWait, state lockDifferenceWait,
        state lockDifference, state unlockDifference,
        accept terminated ;
		
    # Start the simulation rolling.
    init -> initThreads init()[]/@
        machineID, pid, tid = getid();
        cpu(1)@
		
    # STUDENT: Initialize the pcb HERE before spwaning any other threads.
	# Initialize all locks to open and all mutex queues to empty.
    initThreads -> lockSum cpu()[@tid == 0@]/@
        loopGrandTotal = loopLimit * threadCount ;
        pcb.sharedSum = 0 ;
        pcb.sharedDifference = 0 ;
		pcb.mutexAddLock = 0;
		pcb.mutexAddQueue = Queue(False);
		pcb.mutexSubLock = 0;
		pcb.mutexSubQueue = Queue(False);
        spawn();
        cpu(3)@
		
    # All but the final thread spawns its successor.
    initThreads -> lockSum cpu()[@tid > 0 and tid < (threadCount-1)@]/@
        spawn();
        cpu(1)@
    # All but the final thread spawns its successor.
    initThreads -> lockSum cpu()[@tid == (threadCount-1)@]/@
        cpu(3)@
		
    # Fetch sum into register after locking the atomic or mutex.
    lockSum -> fetchSum cpu()[@pcb.mutexAddLock == 0@]/@
		pcb.mutexAddLock = 1;
        sumRegister = pcb.sharedSum ;
        cpu(1)@
	
	# Go to the wait state and be placed inside a queue until the lock is
	# open and it is your turn in the queue.
	lockSum -> lockSumWait cpu()[@pcb.mutexAddLock == 1@]/@
		pcb.mutexAddQueue.enq(thread);
		waitForEvent('wakeup')@
	
	# The lock is now open, the first thread in the queue will transition back.
	lockSumWait -> lockSum wakeup()[]/@
		cpu(12)@
		
    # Add 1 to the sum in the register.
    fetchSum -> addSum cpu()[]/@
        sumRegister += 1 ;
        cpu(1)@
		
    # store the register back into regular memory via the pcb.
    addSum -> storeSum cpu()[]/@
        pcb.sharedSum = sumRegister ;
        cpu(1)@
		
    # release the atomic spin lock or mutex
	# Send a wakeup signal to the first thread in the mutex queue unless its empty
    storeSum -> unlockSum cpu()[]/@
		pcb.mutexAddLock = 0;
		signalEvent(pcb.mutexAddQueue.deq(), 'wakeup') if pcb.mutexAddQueue.len() else noop();
        cpu(3)@
		
    # NOW DO THE EQUIVALENT FOR DIFFERENCE
    unlockSum -> lockDifference cpu()[]/@
        cpu(3)@
		
    # Fetch difference into register after locking the atomic or mutex.
    lockDifference -> fetchDifference cpu()[@pcb.mutexSubLock == 0@]/@
		pcb.mutexSubLock = 1;
        differenceRegister = pcb.sharedDifference ;
        cpu(1)@
	
	# Go to the wait state and be placed inside a queue until the lock is
	# open and it is your turn in the queue.
	lockDifference -> lockDifferenceWait cpu()[@pcb.mutexSubLock == 1@]/@
		pcb.mutexAddQueue.enq(thread);
		waitForEvent('wakeup')@		
	
	# The lock is now open, the first thread in the queue will transition back.
	lockDifferenceWait -> lockDifference wakeup()[]/@
		cpu(12)@	
		
    # Add 1 to the difference in the register.
    fetchDifference -> addDifference cpu()[]/@
        differenceRegister -= 1 ;
        cpu(1)@
		
    # store the register back into regular memory via the pcb.
    addDifference -> storeDifference cpu()[]/@
        pcb.sharedDifference = differenceRegister ;
        cpu(1)@
		
    # release the atomic spin lock or mutex
	# Send a wakeup signal to the first thread in the mutex queue unless its empty
    storeDifference -> unlockDifference cpu()[]/@
		pcb.mutexSubLock = 0;
		signalEvent(pcb.mutexSubQueue.deq(), 'wakeup') if pcb.mutexSubQueue.len() else noop();
        cpu(3)@
		
    # Do cycle again until loopLimit is hit.
    unlockDifference -> lockSum cpu()[@(loopCount+1) < loopLimit@]/@
        loopCount += 1 ;
        cpu(3)@
		
    unlockDifference -> terminated cpu()[@(loopCount+1) == loopLimit@]/@
        msg("ENDTHREAD," + str(tid) + ",SHAREDSUM," + str(pcb.sharedSum)
            + ",SHAREDDIFF," + str(pcb.sharedDifference))@
}

processor

