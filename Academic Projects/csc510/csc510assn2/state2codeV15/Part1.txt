Author:		Christian Carreras
Assignment:	#2
Course Number:	CSC 510
Course Name:	Advanced Operating Systems
Due Date:	10/12/2017
Professor:	Dr. Parson
School:		Kutztown University

JVMVMARGS = "-Xint"

Sub Times:
real  7m5.473s
user 14m32.281s
sys   0m16.870s

Token Times:
real  7m14.725s
user 15m11.898s
sys   0m14.812s

By issuing the -Xint compiler command, it runs each application
in interpreted-only  mode. Native code is not compiled and all 
byte code is executed by the interpreter. Now both the sub and
token VMs are running at the same performance level. The
reason to this now level playing field is that being forced
to interpret all the code goes against what the JIT compiler is
there for. Before, the subroutine-threaded VM performed minutes
faster because the JIT compiler was able to compile the
subroutines at run-time and make them into highly optimized
machine code. The same can not be said for the token-threaded
VM because it will not benefit near as much from being compiled
at run-time and being turned into machine-code. Because it is
using tokens instead of subroutines the tokens will not be
be found by the JIT compiler and cannot be optimized. That being 
said, being interpreted and having each instruction executed
directly without being compiled first in most cases creates an
environment where neither will have a clear advantage.

JIT compilation improves the time of the subroutine-threaded code
substantially faster than token-threaded code because the JIT
compiler can compile code at run-time. Because the subroutines in
the subroutine-threaded code are being called often the JIT compiler
picks up on this and flags the methods to be scheduled for
compilation into machine code. Since the compilation happens
on a separate JVM thread there will be no interrupt or performance
loss. In fact since the methods are turned into highly optimized
host-machine code it lets the code be used extremely fast.
Because of the JIT optimization of the subroutines in the
subroutine-threaded code, we see a tremendous performace boost
which shows why it runs minutes faster than the token-threaded code.
The reason why this contrasts the first assignment is because the
C language does not have access to such a compiler. Both would
be on a level playing field from the beginning. 
