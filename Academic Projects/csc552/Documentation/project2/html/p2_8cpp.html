<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>CSC552Project2: p2.cpp File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.6.1 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <img id="MSearchSelect" src="search/search.png"
             onmouseover="return searchBox.OnSearchSelectShow()"
             onmouseout="return searchBox.OnSearchSelectHide()"
             alt=""/>
        <input type="text" id="MSearchField" value="Search" accesskey="S"
             onfocus="searchBox.OnSearchFieldFocus(true)" 
             onblur="searchBox.OnSearchFieldFocus(false)" 
             onkeyup="searchBox.OnSearchFieldChange(event)"/>
        <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
        </div>
      </li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>p2.cpp File Reference</h1>
<p>This project aims to replicate a client/server environment by using concurrent processes and IPC mechanisms. The client and server will each have their separate process as well as their own read and write ends from two separate pipes. To start, two pipes are created and then a second process is forked to separate the client and server. The client is the parent process and the server is the child. Each process will close the pipe ends that they will never use. The server will redirect its pipe ends to stdin and stdout and then exec while the client will send the file descriptors for the pipe ends being used as arguments in the exec function. All errors with pipes, forks, and execs are being accounted for with the use of perror (stderr).  
<a href="#_details">More...</a></p>
<code>#include &lt;iostream&gt;</code><br/>
<code>#include &lt;cstdio&gt;</code><br/>
<code>#include &lt;sstream&gt;</code><br/>
<code>#include &lt;sys/wait.h&gt;</code><br/>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="p2_8cpp.html#a815a7c06d22e389b397b9520e6022a87">makeExec</a> (const char *)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function takes a single argument of const char* and returns a similar const char* with the exception being './' precedes the argument value. This is necessary for proper execution in a Unix environment. Without this addition to an executable name, every exec function will fail.  <a href="#a815a7c06d22e389b397b9520e6022a87"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="p2_8cpp.html#a885489e77b93121eada5ba44d710e74e">toCString</a> (int)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function takes a single argument of int and returns the equivalent in const char*. This is necessary in order to pass the int value as a argument in any exec function. In this project it is used to pass pipe ends to a process so that process can send and receive information through a single or numerous pipes.  <a href="#a885489e77b93121eada5ba44d710e74e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="p2_8cpp.html#a16c595425376e45620a0c627b6585cb4">parentProcess</a> (int[], int[])</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function will be called by the parent process after the fork. It will close any unused pipe ends in the two given arguments, create any necessary arguments to pass through exec and then finally call exec thus running the client executable.  <a href="#a16c595425376e45620a0c627b6585cb4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="p2_8cpp.html#a4a3e6890f6e9755839ccfc113da2b697">childProcess</a> (int[], int[])</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function will be called by the child process after the fork. It will close any unused pipe ends in the two given arguments, create any necessary arguments to pass through exec and then finally call exec thus running the server executable.  <a href="#a4a3e6890f6e9755839ccfc113da2b697"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="p2_8cpp.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main</a> ()</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a4a3e6890f6e9755839ccfc113da2b697"></a><!-- doxytag: member="p2.cpp::childProcess" ref="a4a3e6890f6e9755839ccfc113da2b697" args="(int[], int[])" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void childProcess </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>c2s</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>s2c</em>[]</td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>* Function Name: childProcess Function Type: mutator Parameters: int[] - import/export - pipe 1 int[] - import/export - pipe 2 Return Value: void</p>
<p>The child process will implement the server side of the project. First all usused pipe ends will be closed by using the array parameters given. Then the pipe ends that will be used will be redirected towards stdin and stdout since the server will only communicate with the client. The redirection is done by the dup2 function. Lastly the server executable will be transformed into the correct format so exec can use it properly. </p>

<p><div class="fragment"><pre class="fragment"><a name="l00191"></a>00191                                         {
<a name="l00192"></a>00192         <span class="keyword">const</span> <span class="keywordtype">char</span> *server;
<a name="l00193"></a>00193         <span class="comment">//Close unused pipe ends</span>
<a name="l00194"></a>00194         close(s2c[0]);          
<a name="l00195"></a>00195         close(c2s[1]);
<a name="l00196"></a>00196         dup2(c2s[0], 0); <span class="comment">//Redirect to stdin</span>
<a name="l00197"></a>00197         dup2(s2c[1], 1); <span class="comment">//Redirect to stdout</span>
<a name="l00198"></a>00198         server = <a class="code" href="p2_8cpp.html#a815a7c06d22e389b397b9520e6022a87" title="This function takes a single argument of const char* and returns a similar const...">makeExec</a>(<span class="stringliteral">&quot;server&quot;</span>); <span class="comment">//Create argument for exec</span>
<a name="l00199"></a>00199         execlp(server, NULL);
<a name="l00200"></a>00200 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ae66f6b31b5ad750f1fe042a706a4e3d4"></a><!-- doxytag: member="p2.cpp::main" ref="ae66f6b31b5ad750f1fe042a706a4e3d4" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int main </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><div class="fragment"><pre class="fragment"><a name="l00095"></a>00095            {
<a name="l00096"></a>00096         pid_t isParent; <span class="comment">//Easily differentiate between child and parent process</span>
<a name="l00097"></a>00097         <span class="comment">//File descriptors to use for pipe creation</span>
<a name="l00098"></a>00098         <span class="keywordtype">int</span> client2Server_fd[2];
<a name="l00099"></a>00099         <span class="keywordtype">int</span> server2Client_fd[2];
<a name="l00100"></a>00100         
<a name="l00101"></a>00101         <span class="comment">//Variables to hold arguments for exec functions</span>
<a name="l00102"></a>00102         <span class="keyword">const</span> <span class="keywordtype">char</span> *client, *server, *cRead, *cWrite;   
<a name="l00103"></a>00103         
<a name="l00104"></a>00104         <span class="comment">//Create the client to server pipe</span>
<a name="l00105"></a>00105         <span class="comment">//Client will have the write end and the server will have the read end</span>
<a name="l00106"></a>00106         <span class="keywordflow">if</span>(pipe(client2Server_fd) == -1) {
<a name="l00107"></a>00107                 perror(<span class="stringliteral">&quot;Pipe Error -- Client to Server pipe could not be created\n&quot;</span>);
<a name="l00108"></a>00108                 <span class="keywordflow">return</span> 0;
<a name="l00109"></a>00109         }
<a name="l00110"></a>00110         
<a name="l00111"></a>00111         <span class="comment">//Create the server to client pipe</span>
<a name="l00112"></a>00112         <span class="comment">//Server will have the write end and the client will have the read end</span>
<a name="l00113"></a>00113         <span class="keywordflow">if</span>(pipe(server2Client_fd) == -1) {
<a name="l00114"></a>00114                 perror(<span class="stringliteral">&quot;Pipe Error -- Server to Client pipe could not be created\n&quot;</span>);
<a name="l00115"></a>00115                 <span class="keywordflow">return</span> 0;
<a name="l00116"></a>00116         }
<a name="l00117"></a>00117         
<a name="l00118"></a>00118         <span class="comment">//Fork a second process and get the pid of both processes to easily</span>
<a name="l00119"></a>00119         <span class="comment">//determine if it is the child or the parent</span>
<a name="l00120"></a>00120         isParent = fork();
<a name="l00121"></a>00121         <span class="keywordflow">if</span>(isParent) {  
<a name="l00122"></a>00122                 <a class="code" href="p2_8cpp.html#a16c595425376e45620a0c627b6585cb4" title="This function will be called by the parent process after the fork. It will close...">parentProcess</a>(client2Server_fd, server2Client_fd);
<a name="l00123"></a>00123                 perror(<span class="stringliteral">&quot;Parent exec failed\n&quot;</span>); <span class="comment">//Should only fire if exec failed</span>
<a name="l00124"></a>00124         }
<a name="l00125"></a>00125         <span class="comment">//If the process is the child</span>
<a name="l00126"></a>00126         <span class="keywordflow">else</span> <span class="keywordflow">if</span>(isParent == 0) {
<a name="l00127"></a>00127                 <a class="code" href="p2_8cpp.html#a4a3e6890f6e9755839ccfc113da2b697" title="This function will be called by the child process after the fork. It will close any...">childProcess</a>(client2Server_fd, server2Client_fd);
<a name="l00128"></a>00128                 perror(<span class="stringliteral">&quot;Child exec failed\n&quot;</span>); <span class="comment">//Should only fire if exec failed</span>
<a name="l00129"></a>00129         }
<a name="l00130"></a>00130         <span class="comment">//If it is not the parent or the child then the fork failed</span>
<a name="l00131"></a>00131         <span class="keywordflow">else</span> {
<a name="l00132"></a>00132                 perror(<span class="stringliteral">&quot;Fork Error -- could not fork another process\n&quot;</span>);
<a name="l00133"></a>00133         }
<a name="l00134"></a>00134         
<a name="l00135"></a>00135         <span class="keywordflow">return</span> 0;
<a name="l00136"></a>00136 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a815a7c06d22e389b397b9520e6022a87"></a><!-- doxytag: member="p2.cpp::makeExec" ref="a815a7c06d22e389b397b9520e6022a87" args="(const char *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * makeExec </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>exe</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>* Function Name: makeExec Function Type: facilitator Parameters: const char* - import only - executable name Return Value: const char* - ready to be used argument for exec</p>
<p>makeExec takes a single const char* argument named exec and concatenates with the string value "./" It then returns the cstring equivalent of that concatenation. i.e the result will look like this: "./exe" This function should be used with every exec function to ensure that it works properly in a Unix environment. </p>

<p><div class="fragment"><pre class="fragment"><a name="l00144"></a>00144 {
<a name="l00145"></a>00145         <span class="keywordtype">string</span> suf = <span class="stringliteral">&quot;./&quot;</span>; <span class="comment">//Unix&apos;s way of opening an executable</span>
<a name="l00146"></a>00146         <span class="keywordtype">string</span> tempStr = suf + exe;
<a name="l00147"></a>00147         <span class="keywordflow">return</span> tempStr.c_str();
<a name="l00148"></a>00148 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a16c595425376e45620a0c627b6585cb4"></a><!-- doxytag: member="p2.cpp::parentProcess" ref="a16c595425376e45620a0c627b6585cb4" args="(int[], int[])" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void parentProcess </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>c2s</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>s2c</em>[]</td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>* Function Name: parentProcess Function Type: mutator Parameters: int[] - import/export - pipe 1 int[] - import/export - pipe 2 Return Value: void</p>
<p>The parent process will implement the client side of the project. First all unused pipe ends will be closed by using the array parameters given. Then the client executable will be be transformed into the correct format so exec can use it properly. Lastly the pipe ends that will be used will be transformed into const char* so they can be used as arguments in the exec. </p>

<p><div class="fragment"><pre class="fragment"><a name="l00171"></a>00171                                          {
<a name="l00172"></a>00172         <span class="keyword">const</span> <span class="keywordtype">char</span> *client, *cRead, *cWrite;
<a name="l00173"></a>00173         <span class="comment">//Close unused pipe ends</span>
<a name="l00174"></a>00174         close(c2s[0]);
<a name="l00175"></a>00175         close(s2c[1]);
<a name="l00176"></a>00176         <span class="comment">//Create arguments for exec</span>
<a name="l00177"></a>00177         client = <a class="code" href="p2_8cpp.html#a815a7c06d22e389b397b9520e6022a87" title="This function takes a single argument of const char* and returns a similar const...">makeExec</a>(<span class="stringliteral">&quot;client&quot;</span>);            
<a name="l00178"></a>00178         cRead = <a class="code" href="p2_8cpp.html#a885489e77b93121eada5ba44d710e74e" title="This function takes a single argument of int and returns the equivalent in const...">toCString</a>(s2c[0]);
<a name="l00179"></a>00179         cWrite = <a class="code" href="p2_8cpp.html#a885489e77b93121eada5ba44d710e74e" title="This function takes a single argument of int and returns the equivalent in const...">toCString</a>(c2s[1]);
<a name="l00180"></a>00180         <span class="comment">//Exec to client process</span>
<a name="l00181"></a>00181         execlp(client, cRead, cWrite, NULL);
<a name="l00182"></a>00182 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a885489e77b93121eada5ba44d710e74e"></a><!-- doxytag: member="p2.cpp::toCString" ref="a885489e77b93121eada5ba44d710e74e" args="(int)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * toCString </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>num</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>* Function Name: toCString Function Type: facilitator Parameters: int - import only - number to become cstring Return Value: const char* - ready to be used argument for exec</p>
<p>toCString takes a single int argument which is to be turned into a const char * value. Stringstream will be used to correctly transfer the int value into a cstring. The int value is put into the stringstream using stream insertion. A temporary string will then hold the string equivalent of the string stream. The temporary string is then turned into the cstring equivalent and returned. </p>

<p><div class="fragment"><pre class="fragment"><a name="l00158"></a>00158 {
<a name="l00159"></a>00159         stringstream sstr;
<a name="l00160"></a>00160         sstr &lt;&lt; num;
<a name="l00161"></a>00161         <span class="keywordtype">string</span> tempStr = sstr.str();
<a name="l00162"></a>00162         <span class="keywordflow">return</span> tempStr.c_str();
<a name="l00163"></a>00163 }
</pre></div></p>

</div>
</div>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Functions</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr size="1"/><address style="text-align: right;"><small>Generated on 11 Mar 2017 for CSC552Project2 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
