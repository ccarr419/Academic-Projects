# CSC 343, Fall 2013, STUDENT NAME:
# srtfEstimate.stm (this file) is the preemptive Shortest Time
# Remaining First variant of SJF.
# sjfEstimate.stm extends sjf.txt by making estimates of the next
# CPU burst time, based on the formula in the book. See variables
# lastEstimate and lastBurst and weight lastAlpha. It is non-preeemptive.
# sjf.stm implements a short-job first, non-preemptive scheduler as a
# partial solution of assignment 2. D. Parson.

machine processor {
    # Use this machine in all of your files in assignment 2 to start threads.
    # It starts 10 threads, one every tick. I am starting them quickly so that
    # algorithms like FCFS don't get swamped too much an early CPU-bound thread.
    threadsToGo = 10, pid = -1, tid = -1 ;
    start init, state makingThreads, accept doneStartingThreads ;
    init -> makingThreads init()[]/@
        processor.readyq = Queue(ispriority=True);
        threadsToGo -= 1 ; fork()@
    makingThreads -> makingThreads fork(pid, tid)[@threadsToGo > 0@]/@
        threadsToGo -= 1 ; fork()@
    makingThreads -> doneStartingThreads fork(pid, tid)[@threadsToGo == 0@]/
}

# For all parts of your assignment, half of every ten threads must be IO bound.
# The others are CPU bound. The I/O bound threads must request between
# 1 and 250 ticks using the exponential sampler, with the knee of the curve
# (half of the sampled values) at 25 ticks. The CPU bound threads must
# request between 100 and 1100 ticks using the revexponential sampler,
# with the knee of the curve (half of the sampled values) at 1000 ticks.
# All threads must continue to run until simulation time is >= 100,000.
machine thread {
    machineid = -1, pid = -1, tid = -1, iobound = @False@, endtime = 100000,
        cpuburst = -1, iodevice = -2,
        # The next three variables are for estimating burst sizes.
        lastEstimate = 1, lastBurst = 1, lastAlpha = 0.5,
        # burstLeeway is fraction of lastEstimate allowed before preemption.
        burstLeeway = 1.1 ;
    # Python treats 0 as False (not iobound) and 1 as True (iobound).
    # The transition out of state init initializes the above variables.
    start init, state scheduling, state ready, state running, state waiting,
        state rescheduling, accept terminated ;
    init -> scheduling init()[]/@machineid, pid, tid = getid();
        from math import ceil ;
        iobound = True if ((pid % 2) == 1) else False ;
        # ^^^ The odd pids are IO bound.
        # The others (50%) are CPU bound. This job mix stresses the scheduling
        # algorithms better than a strictly IO-bound or CPU-bound mix.
        # Set cpuburst when going into scheduling.
        lastEstimate = (lastAlpha * lastBurst)
            + ((1.0 - lastAlpha) * lastEstimate);
        cpuburst = sample(1, 250, 'exponential', 25) if iobound
            else sample(100, 1100, 'revexponential', 1000);
        # Let it run at most 110% of the current estimate until preemption,
        # then adjust upward if needed the next time around.
        cpuburst = cpuburst if (cpuburst <= (lastEstimate * burstLeeway))
            else (lastEstimate * burstLeeway);
        cpuburst = int(ceil(cpuburst));
        lastBurst = cpuburst ;
        yieldcpu()@
    scheduling -> running yieldcpu()[@processor.contextsFree > 0@]/@
        processor.contextsFree -= 1 ;
        msg('pid ' + str(pid) + ' tid ' + str(tid) + ' about to CPU for '
            + str(cpuburst) + ' ticks'); cpu(cpuburst)@
    scheduling -> ready yieldcpu()[@processor.contextsFree == 0@]/@
        # Put myself in processor's readyq with sjf priority.
        msg('pid ' + str(pid) + ' tid ' + str(tid)
            + ' about to wait, ready for CPU ticks ' + str(cpuburst));
        processor.readyq.enq(thread, lastEstimate);
        waitForEvent('contextReady', False)@
    ready -> scheduling contextReady()[]/@yieldcpu()@
    # ^^^ Do not set ticks coming out of ready, not used yet.
    running -> rescheduling cpu()[]/@
        processor.contextsFree += 1 ;
        msg('thread ' + str(tid) + ' checking readyq '
            + str(len(processor.readyq))
            + ' with contextsFree ' + str(processor.contextsFree));
        signalEvent(processor.readyq.deq(), 'contextReady')
            if len(processor.readyq) > 0 else noop();
        yieldcpu()@
    rescheduling -> terminated yieldcpu()[@time() >= endtime@]/
    rescheduling -> waiting yieldcpu()[@time() < endtime@]/@
        # iodevice of -1 (process terminal) or one of the fastio devices.
        iodevice = sample(-1, len(processor.fastio)-1, 'uniform');
        msg('thread ' + str(tid) + ' blocking on IO unit ' + str(iodevice));
        msg('pid ' + str(pid) + ' tid ' + str(tid) + ' about to IO on dev '
            + str(iodevice));
        io(iodevice)@
    waiting -> scheduling io()[]/@
        lastEstimate = (lastAlpha * lastBurst)
            + ((1.0 - lastAlpha) * lastEstimate);
        cpuburst = sample(1, 250, 'exponential', 25) if iobound
            else sample(100, 1100, 'revexponential', 1000);
        # Let it run at most 110% of the current estimate until preemption,
        # then adjust upward if needed the next time around.
        cpuburst = cpuburst if (cpuburst <= (lastEstimate * burstLeeway))
            else (lastEstimate * burstLeeway);
        cpuburst = int(ceil(cpuburst));
        lastBurst = cpuburst ;
        yieldcpu()@
}

processor
