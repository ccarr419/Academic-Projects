# mergeSort.txt
# A merge sort that strictly uses recursion -- no iteration.
# D. Parson, CSC 526, Spring 2012.
# Based on loop bearing code in http://en.wikipedia.org/wiki/Merge_sort

# FROM http://en.wikipedia.org/wiki/Merge_sort:
#   function merge(left, right)
#       var list result
#       while length(left) > 0 or length(right) > 0
#           if length(left) > 0 and length(right) > 0
#               if first(left) <= first(right)
#                   append first(left) to result
#                   left = rest(left)
#               else
#                   append first(right) to result
#                   right = rest(right)
#           else if length(left) > 0
#               append first(left) to result
#               left = rest(left)
#           else if length(right) > 0
#               append first(right) to result
#               right = rest(right)
#       end while
#       return result

int [] merge = function(int [] onearray, int midpoint) {
    # adapted from above for MiniML.
    int [] whileloop = function(int [] onearray, int leftix, int leftbound,
            int rightix, int rightbound, int [] result) {
        return (
            (leftix == leftbound)
            ? (rightix == rightbound ? result
                : whileloop(onearray, leftix, leftbound,
                    rightix+1, rightbound, result + [onearray[rightix]]))
            : rightix == rightbound
                ? whileloop(onearray, leftix+1, leftbound,
                    rightix, rightbound, result + [onearray[leftix]])
                : onearray[leftix] <= onearray[rightix]
                    ? whileloop(onearray, leftix+1, leftbound,
                        rightix, rightbound, result + [onearray[leftix]])
                    : whileloop(onearray, leftix, leftbound,
                        rightix+1, rightbound, result + [onearray[rightix]]));
    }
    return whileloop(onearray, 0, midpoint, midpoint, length(onearray), []);
}

# FROM http://en.wikipedia.org/wiki/Merge_sort:
#   function merge_sort(list m)
#       // if list size is 1, consider it sorted and return it
#       if length(m) <= 1
#           return m
#       // else list size is > 1, so split the list into two sublists
#       var list left, right
#       var integer middle = length(m) / 2
#       for each x in m up to middle
#            add x to left
#       for each x in m after or equal middle
#            add x to right
#       // recursively call merge_sort() to further split each sublist
#       // until sublist size is 1
#       left = merge_sort(left)
#       right = merge_sort(right)
#       // merge the sublists returned from prior calls to merge_sort()
#       // and return the resulting merged sublist
#       return merge(left, right)

int [] merge_sort = function(int [] m) {
    int [] merge_sort_a_partition = function(int [] marray,
            int start, int end, int threadCount) {
        int mid = (start+end)/2 ;
        int threadLimit = 16 ;
        return(start >= end ? []
            : start == (end-1) ? [marray[start]]
            : merge(threadCount < threadLimit
                    ? {{ reduce
                        + merge_sort_a_partition(marray, start, mid,
                            threadCount * 2);
                        merge_sort_a_partition(marray, mid, end,
                            threadCount * 2); }}
                    : (merge_sort_a_partition(marray, start, mid, threadCount)
                        + merge_sort_a_partition(marray, mid, end, threadCount)),
                mid-start));
    }
    return merge_sort_a_partition(m, 0, length(m), 1);
}

string printiarray = function(int [] iarray, int i) {
    return (i > -1 && i < length(iarray))
        ? (iarray[i] ~ printiarray(iarray, i+1))
        : ' ';
}

int [] makeBigArray = function(int bound) {
    int [] helpmakeArray = function(int thcount, int frontier, int bound, int [] sofar) {
        int usethreads = 16 ;
        return (frontier >= bound) ? sofar
            : (thcount >= usethreads)
                ? helpmakeArray(thcount, frontier + 1, bound, sofar + [frontier, -frontier])
                : sofar + {{ reduce + helpmakeArray(thcount*2, frontier, bound/2, []);
                    helpmakeArray(thcount*2, bound/2, bound, []); }} ; }
    return helpmakeArray(1, 0, bound, []);
}

int [] inarray = makeBigArray(60000);
'pre-ms';
printiarray(inarray, 0);
'ms';
printiarray(merge_sort(inarray), 0);
