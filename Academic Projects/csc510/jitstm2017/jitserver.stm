# CSC 510, Fall 2017. D. Parson handout code.
# jitserver.stm models JIT compilation tradeoffs for the -server
# option of the JVM (this is the default) to compare
# -server (compile after 10,000 hits on each STEP opcode and the
# main call() loop), -Xint (jitXint.stm: never JIT compile),
# and -Xcomp (jitXcomp.stm: compile right away on the first hit on an opcode).
# This simulation scales back two basic measure by a factor of
# 1000 in order to speed the simulation; see comments on variables
# evalLoops and CompileAfter below. Also, we are skipping -Xcomp.

# STM processor IS COMPLETE AS IS.
machine processor {
    # fork() one process, which creates its thread 0.
    # It spawns another thread.
    tid = -1, pid = -1 ;
    start init, state startCallProcess, accept doneStarting ;
    init -> startCallProcess init()[]/@fork()@
    startCallProcess -> doneStarting fork(pid, tid)[]/
}

# STM thread IS WHERE STUDENT WORK GOES. SOME TRANSITIONS ARE COMPLETE.
machine thread {
    # See csc510 assn3 analysis in assignment handout.
    # CompileAfter is 10 (10000 scaled down by / 1000) for -server,
    # 1 for -Xcomp, -1 for -Xint, where -1 lets the JIT thread 0
    # terminate without doing anything. We are skipping -Xcomp
    # because that would require modeling the overhead of unrelated
    # library function calls with less than 10,000 invocations.
    # evalLoops is 100,000, which is 100,000,000 from the stepvm
    # benchmarks, scaled down by / 1000.
    # pcb.opcodeSubState maps each opcode to its byte size, used to figure
    # cost, and the number of times the JIT compiler must visit it
    # before compilation is complete. JIT thread 0 decrements that
    # count, once per visit, until it hits 0.
    # Only when it hits 0 do we consider JIT compilation to be in effect.
    # StepVM thread 1 notifies JIT thread 0 every time it emulates
    # an opcode with that count > 0. StepVM thread 1 also notifies
    # JIT thread 0 every time the main STM loop, which emulates
    # the ::call() loop, executes STEP_GOTO. After the counter hits 0,
    # StepVM thread 1 runs the instruction at JITSCALE * bytes without
    # notifying JIT Thread 0 for that opcode. Before it hits 0, StepVM
    # thread 1 runs the instruction at INTSCALE * bytes and notifies
    # JIT Thread 0 of the instruction.
    # StepVM Thread 1 does not wait for JIT Thread 0 to respond or
    # synchronize in any way.
    # STM variables INTSCALE through costOfCallThread are config and
    # state variables, costOfCallThread accumulating and reporting
    # the scaled cost of running the main ::call() loop's opcodes.
    # timeUntilJIT through callbytes are my temporary, local variables
    # that hold results of temporary calculations; you may create others.
    # The pseudo-code does reflect mine.
    # Configuration variables:
    INTSCALE = 0.869, JITSCALE = 0.062, CompileAfter = 10,
    # State variables:
    evalLoops = 100000, IP = 0, isdone = @False@, costOfCallThread = 0.0,
    # Temporary variables
    timeUntilJIT = 0, bytes = 0, opcode = "NOOPCODE",
    timeUntilCallJIT = 0, callbytes = 0,
    # The emulated StepVM program:
    TestIdleLoop = @[
        "STEP_CONST", "STEP_DUP", "STEP_CONST", "STEP_LSUB",
        "STEP_DUP", "STEP_GOTO0", "STEP_GOTO", "STEP_PRINT",
        "STEP_CRLF", "STEP_PRINT", "STEP_CRLF", "STEP_PAUSE"
    ]@;
    # STATES: STUDENT 1: List the remaining states from the graph.
    start init, state initTidEtc, state compile, state fetch, state execute,
        accept terminated ;

    # Initialize variables used by all threads:
    # THIS IS COMPLETE.
    init -> initTidEtc init()[]/@machineid, pid, tid = getid();
        # [BYTESIZE, NUMBER_OF_INVOCATIONS_UNTIL_JIT_COMPILE]
        # access bytes as pcb.opcodeSubState[opcodeString][0]
        # access counter as pcb.opcodeSubState[opcodeString][1]
        pcb.opcodeSubState = {
            "STEP_CONST" : [58, CompileAfter+3],
            "STEP_DUP" : [49, CompileAfter+3],
            "STEP_LSUB" : [84, CompileAfter+3],
            "STEP_GOTO0" : [88, CompileAfter+4],
            "STEP_GOTO" : [28, CompileAfter+3],
            "STEP_PRINT" : [61, CompileAfter+3],
            "STEP_CRLF" : [61, CompileAfter+3],
            "STEP_PAUSE" : [61, CompileAfter+3],
            "call" : [1021, CompileAfter+5],
        };
        yieldcpu()@
    # Thread 0 is the emulated JIT compiler thread.
    initTidEtc -> terminated yieldcpu()[@tid == 0 and CompileAfter <= 0@]/@
        # Start application thread 1, then abort for -Xint:
        # Set pcb.jitcompiler so ::call() thread 1 can send signalEvent().
        pcb.jitcompiler = thread ;
        spawn() ; yieldcpu()@
    initTidEtc -> compile yieldcpu()[@tid == 0 and CompileAfter > 0@]/@
        # Start ::call() thread 1, then spin in compile state loop until done.
        # Set pcb.jitcompiler so ::call() thread 1 can send signalEvent().
        pcb.jitcompiler = thread ;
        spawn() ; waitForEvent("executeEvent", False)@
    compile -> terminated executeEvent(opcode)[@opcode == "terminate"@]/@
        # Incoming opcode from ::call() thread 1 either "terminate"
        # or a valid opcode string.
        yieldcpu()@
        
    # STUDENT 2: compile -> compile
    # 2.1 Use a guard that is the inverse of the previous transition above.
    # 2.2 If the coundown counter on this opcode is > 0,
    #     then decrement it by 1.
    # 2.3 Last statement: waitForEvent("executeEvent", False)
    compile -> compile executeEvent(opcode)[@opcode != "terminate"@]/@
        if pcb.opcodeSubState[opcode][1] > 0 :
            pcb.opcodeSubState[opcode][1] -= 1 ;
        waitForEvent("executeEvent", False)@

    # Thread 1 emulates the main loop in ::call().
    initTidEtc -> fetch yieldcpu()[@tid == 1@]/@
        yieldcpu()@

    # LEAVE THIS TRANSITION AS IT IS.
    fetch -> terminated yieldcpu()[@isdone@]/@
        msg("COST FOR APPLICATION THREAD ::call() is !"
            + str(costOfCallThread) + "!")@

    # STUDENT 3: fetch -> execute
    # 3.1: Use a guard that is the inverse of the previous transition above.
    # 3.2: Update local var opcode (string) using TestIdleLoop and IP.
    # 3.3: Update local var bytes using pcb.opcodeSubState and opcode.
    # 3.4: Update local var callbytes using pcb.opcodeSubState and "call".
    # 3.5: Update local var timeUntilJIT using pcb.opcodeSubState, opcode,
    #      and CompileAfter. If CompileAfter is less than or equal to 0,
    #      there will be no JIT compilation. I used a conditional expression
    #      and set timeUntilJIT to 1 on that case, i.e., not 0.
    # 3.6: Update local var timeUntilCallJIT similarly to previous step,
    #      using "call" instead of opcode string.
    # 3.7: Last statement: yieldcpu()
    # STUDENT: The local vars set in this transition are used in the next one:
    fetch -> execute yieldcpu()[@not isdone@]/@
        opcode = TestIdleLoop[IP] ;
        bytes = pcb.opcodeSubState[opcode][0] ;
        callbytes = pcb.opcodeSubState["call"][0] ;
        timeUntilJIT = pcb.opcodeSubState[opcode][1] 
            if CompileAfter > 0 else 1 ;
        timeUntilCallJIT = pcb.opcodeSubState["call"][1] 
            if CompileAfter > 0 else 1 ;
        yieldcpu()@

    # STUDENT 4: execute -> fetch; there is no guard.
    # 4.1: Set isdone to True if opcode is "STEP_PAUSE", else False.
    #      I just used a simple boolean expression on the RHS of assignment.
    # 4.2: If opcode is "STEP_GOTO", decrement STM variable evalLoops.
    # 4.3: Add the cost of opcode into costOfCallThread, where cost
    #      is bytes TIMES the scale, and scale is INTSCALE if timeUntilJIT
    #      is greater than 0, else scale is JITSCALE.
    # 4.4: Add the cost of the "call" loop into costOfCallThread,
    #      if and only if opcode string is "STEP_GOTO" (the loop's tail).
    #      Cost is computed using bytes TIMES either INTSCALE or JITSCALE,
    #      same as previous step. I used a nested conditional expression
    #      and a cost of 0 if opcode string is not "STEP_GOTO".
    # 4.5: Update StepVM IP (instruction pointer) with 3 if opcode string
    #      is "STEP_GOTO", else with 7 if opcode string is "STEP_GOTO0"
    #      AND evalLoops is less than or equal to 0, else IP+1 for the default
    #      case. I used a nested conditional expression for the new value
    #      of IP. We are simulating the gotos in the program.
    # 4.6: If simulation is NOT isdone, AND timeUntilCallJIT is greater than 0,
    #      AND CompileAfter is greater than 0,
    #      AND opcode string is "STEP_GOTO", call this function to
    #      send an event to the JIT compiler thread:
    #           signalEvent(pcb.jitcompiler, "executeEvent", "call");
    # 4.7: If the simulation isdone, call this function:
    #           signalEvent(pcb.jitcompiler, "executeEvent", "terminate")
    #      Else if timeUntilJIT is greater than 0
    #               AND CompileAfter is greater than 0, call this:
    #           signalEvent(pcb.jitcompiler, "executeEvent", opcode)
    # I used a nested conditional expression, supplying a value of None
    # for the default "Else" (not shown in this pseudo-code).
    # 4.8: Last statement: yieldcpu()
    execute -> fetch yieldcpu()[]/@
        isdone = True if opcode == "STEP_PAUSE" else False ;
        
        if opcode == "STEP_GOTO":
            evalLoops -= 1 ;
        
        costOfCallThread += 
            pcb.opcodeSubState[opcode][0] * INTSCALE
            if timeUntilJIT > 0
            else pcb.opcodeSubState[opcode][0] * JITSCALE ;
            
        costOfCallThread += 
            pcb.opcodeSubState["call"][0] * INTSCALE
                if timeUntilJIT > 0 and opcode == "STEP_GOTO"
            else pcb.opcodeSubState["call"][0] * JITSCALE
                if timeUntilJIT <= 0 and opcode == "STEP_GOTO"
            else 0 ;
        
        IP = 3 if opcode == "STEP_GOTO" 
            else 7 if opcode == "STEP_GOTO0" and evalLoops <= 0 else IP+1 ;
            
        if not isdone and timeUntilCallJIT > 0 and CompileAfter > 0 
            and opcode == "STEP_GOTO" :
            signalEvent(pcb.jitcompiler, "executeEvent", "call") ;       
        
        signalEvent(pcb.jitcompiler, "executeEvent", "terminate")
            if isdone 
        else signalEvent(pcb.jitcompiler, "executeEvent", opcode)
            if timeUntilJIT > 0 and CompileAfter > 0 
        else None ;

        yieldcpu()@
}
processor
