# CSC343Compile.py, D. Parson, Fall 2013 CSC343 Operating Systems
# CSC343Compile.py supplies the back end of state machine parser
# State2CodeParser.py (the target-neutral compiler front end).
# CSC343Compile.py generates target code from a  "*.stm" state machine
# description to run on target virtual machine specified in CSC343Sim.py.
# See State2CodeParser.py, CSC343Sim.py and CSC343.template.txt.
# V14 replaces has_key and sort() on keys() for preparation to move
# to Python 3 in V15. August 2017.

# Modifications By:     Christian Carreras
# File Name:            CSC343Compile.py
# Due Date:             10/12/2017
# Assignment:           #2 (Part 2)
# Professor/Author:     Dr. Dale Parson
# Course Number:        CSC510
# Course Name:          Advanced Operating Systems
# University:           Kutztown University
# Major:                CSCM Software Development
# Purpose:              Accelerating the Python-based run-time environment of 
#                       the CSC 343 State machine (STM) simulator by compiling 
#                       generated Python source expressions and statements into
#                       Python token-threaded byte codes. This part modifies 
#                       and measures code in the state2codeV15/ subdirectory. 

import re
import copy
import sys
from state2codeV15.State2CodeParser import AbstractCodeGenerator, horror

class CSC343Compile(AbstractCodeGenerator):
    def __init__(self):
        pass
    def generate(self, parseTree, symtab, objfile):
        # STUDENT 1: My solution initializes local variable codeTable to
        # the empty list here. All of your work for Fall 2017 csc510 assn2 goes
        # into this function generate() that generates code, so a local variable
        # will do.  This codeTable is where your code additions must build
        # up strings of Python compile() statements that you will emit as
        # lines of code, just before emitting the __main__ code at the bottom
        # of this function. Here you just set codeTable to the empty list.
        # See test343SLOW.py.dif.txt in this directory to see the differences
        # between the starting point of code generated by this file for
        # test application test343SLOW.stm, and the end point.
        # MAKE CERTAIN TO SET YOUR TEXT
        # EDITOR SO THAT A TAB EXPAND TO SPACES, GOING TO THE NEXT 4-SPACE
        # COLUMN. YOUR INDENTATION MUST MATCH MINE FOR PYTHON TO WORK,
        # AND MIXING TABS & SPACES WILL CAUSE PROBLEMS. I DON'T USE TAB
        # CHARACTERS IN PYTHON CODE, AND YOU ARE MAKIN SMALL EXTENSIONS
        # TO MY CODE.
        __codeTable__ = []
        
        reserved = { 'processor' : set([
                'fork', 'idle', 'contextCount', 'contextsFree', 'trigger',
                'waitForEvent', 'signalEvent', 'noop', 'Queue',
                'tid2thread', 'time', 'sample', 'msg', 'context',
                'fastio', 'readyq', 'assign', 'self', 'wait', 'exit']),
            'thread' : set([
                'waitForEvent', 'signalEvent', 'noop', 'Queue',
                'fork', 'spawn', 'retire', 'cpu', 'io', 'sleep', 'yieldcpu',
                'trigger', 'sample', 'getid', 'msg', 'context', 'thread',
                'pcb', 'child', 'fastio', 'processor', 'assign', 'self',
                'kill', 'exit', 'wait', 'join'])
            }
        # Added Oct 3 2013 to be super safe:
        reserved['processor'] = reserved['processor'].union(reserved['thread'])
        reserved['thread'] = reserved['processor'].union(reserved['thread'])
        reserved['all'] = reserved['processor'].union(reserved['thread'])
        lastact = {'processor' : set(['fork', 'idle', 'trigger',
            'waitForEvent', 'wait'])}
        lastact['thread'] = set(['fork', 'spawn', 'retire', 'cpu', 'io',
            'sleep', 'yieldcpu', 'trigger', 'waitForEvent',
            'wait', 'join'])
        lastact['subgraph'] = lastact['processor'].union(lastact['thread'])
        # Do not allow state or event names from the following set, 10/24/2014
        reservedNoEventState = set([
            'contextCount', 'contextsFree', 'trigger',
            'waitForEvent', 'signalEvent', 'noop', 'Queue',
            'tid2thread', 'time', 'sample', 'msg', 'context',
            'fastio', 'readyq', 'self', 'retire', 'getid', 
            'pcb', 'child', 'fastio', 'processor', 'thread', 'assign', 'self',
            ])
        reserved['processor'] = reserved['processor'].union(
            reservedNoEventState)
        reserved['thread'] = reserved['thread'].union(reservedNoEventState)
        reserved['all'] = reserved['all'].union(reservedNoEventState)
        def flatline(string):
            result = None
            if string:
                result = string.strip()
                nl = result.find('\n')
                while nl >= 0:
                    result = result[:nl] + ' ' + result[nl+1:]
                    nl = result.find('\n')
                result = result.strip()
            else:
                result = ''
            return result
        def clean(string):
            # clean(string) was discarding acts like
            #   thing1 = "thing2"
            # because of a trailing " or ', so do not discard
            # a delimiter
            result = flatline(string)
            # if len(result) and (result[0] == '"' or result[0] == "'"):
                # result = result[1:]
            # if len(result) and (result[-1] == '"' or result[-1] == "'"):
                # result = result[:-1]
            result = result.strip()
            return result
        def indent(prefix, nesting=0):
            result = prefix
            for i in range(0, nesting):
                result += '    '
            return result
        def checkdelimiters(varname, strval):
            delimiter = "'"
            if "'" in strval:
                delimiter = '"'
            if delimiter in strval:
                horror(ValueError,
                    ('CSC343Compile conflicting delimiters in variable'             \
                        + 'initialization: ' + varname + ' = ' + strval))
            return (delimiter + strval + delimiter)
        def fixdelimiters(strval):
            delimiter = "'"
            if "'" in strval:
                delimiter = '"'
            if delimiter in strval:
                horror(ValueError,
                    ('CSC343Compile conflicting delimiters in'             \
                        + 'expression: ' + strval))
            return (delimiter + strval + delimiter)
        def genvars(smname, sm, prefix, objfile):
            for vname in sm.variables.keys():
                if vname in reserved['all']:
                    horror(ValueError,
                        ("Reserved variable name '" + vname + " in " \
                            + smname + "."))
                vval = sm.variables[vname]
                # parser makes vval the correct type
                if type(vval) == tuple:
                    # A @@ delimited data structure in Python
                    vval = checkdelimiters(vname, vval[0])
                    nl = vval.find('\n')
                    while nl > -1:
                        vval = vval[:nl] + ' ' + vval[nl+1:]
                        nl = vval.find('\n')
                    vval = "eval(" + vval + ",{},{})"
                elif type(vval) == str:
                    vval = checkdelimiters(vname, vval)
                objfile.write(prefix + "'" + vname + "'" + ' : ' + str(vval)  \
                    + ',\n')
                stripped = str(vval)
                stripped = stripped.strip()
                if len(stripped) and stripped[0] == '#':
                    horror(ValueError,
                        ("State machine " + smname + ", variable initializer " \
                            + vname
                            + " has a comment embedded in a"      \
                            + " command: " + stripped             \
                            + ".\nA comment must go on its own line."))
        def genrun(smname, sm, prefix, objfile):
            firststate = True
            for sname in sm.states:
                if sname in reservedNoEventState:
                    horror(ValueError,
                        ("Reserved name '" + sname + "' in " \
                            + smname + " cannot be used as a state name."))
                state = sm.states[sname]
                if (state.isstart and (smname in ['processor', 'thread'])
                        and not (sname == 'init'
                            and len(state.transitions) == 1
                            and state.transitions[0].event == 'init'
                            and (not state.transitions[0].arguments)
                            and (not state.transitions[0].guard))):
                    horror(ValueError,
                        ("Start 'init' state from machine " + smname  \
                            + " must have a single 'init' transition " \
                            + "with no args or guard."))
                # Next is for subgraphs.
                elif (state.isstart and (not smname in ['processor','thread'])
                        and (sname != 'init' or len(state.transitions) != 1
                            or state.transitions[0].event != 'init')):
                    horror(ValueError,
                        ("Start 'init' state from machine " + smname  \
                            + " must have a single 'init' transition " \
                            + "with optional args and/or guard."))
                if state.isaccept and (len(state.transitions) != 0):
                    horror(ValueError,
                      ("Accept state " + sname + " in machine "     \
                        + smname + " may not have transitions."))
                if (not state.isaccept) and (len(state.transitions) == 0):
                    horror(ValueError,
                      ("Regular state " + sname + " in machine "    \
                        + smname + " must have transitions."))
                if firststate:
                    objfile.write(prefix + "if self.state == '" + sname \
                        + "':\n")
                    firststate = False
                else:
                    objfile.write(prefix + "elif self.state == '" + sname \
                        + "':\n")
                firsttrans = True
                if state.isaccept:
                    objfile.write(prefix + '    '
                        + 'self.logger.log(self, tag="DEPART")\n')
                    objfile.write(prefix + "    return\n")
                else:
                    for xt in state.transitions:
                        if not xt.event:
                            horror(ValueError,
                                ("Transition from machine " + smname
                                    + ", state " + sname + " -> "
                                    + xt.destState + " has no event."))
                        elif xt.event in reservedNoEventState:
                            horror(ValueError,
                                ("Reserved name '" + xt.event
                                    + "' cannot be used as an event name "
                                    + "on transition from machine " + smname
                                    + ", state " + sname + " -> "
                                    + xt.destState))
                        if firsttrans:
                            objfile.write(prefix + "    if event == '"   \
                                + xt.event + "':\n")
                            firsttrans = False
                        else:
                            objfile.write(prefix + "    if event == '"   \
                                + xt.event + "':\n")
                            # objfile.write(prefix + "    elif event == '"   \
                                # DEBUG + xt.event + "':\n")
                        if xt.arguments:
                            aglist = xt.arguments.split(',')
                            agix = 0
                            for ag in aglist:
                                ags = clean(ag)
                                if ags:
                                    objfile.write(prefix + "        "       \
                                        + 'locals["' + ags + '"]'       \
                                        + " = args[" + str(agix) + "]\n");
                                    agix += 1
                        if xt.guard:
                            __codeTable__.append("compile("         \
                                + fixdelimiters(flatline(xt.guard)) \
                                + ",'nofile','eval')")
                            objfile.write(prefix + "        if "        \
                                + "eval(__codeTable__["                 \
                                + str(len(__codeTable__)-1) + "],"      \
                                + "globals,locals):\n")
                            #objfile.write(prefix + "        if "        \
                            #    + "eval(" + fixdelimiters(              \
                            #        flatline(xt.guard))                 \
                            #    + ",globals,locals):\n")
                            
                            # STUDENT 2: This "xt.guard:" section is the
                            # block of code that generates code for STM
                            # conditional statements. We use eval instead
                            # of exec in order to get a boolean result from
                            # expression evaluation. My solution comments
                            # out the above 4 lines of code in this "if"
                            # block (keep "if xt.guard:" as it is), replacing
                            # them with the following logic:
                            # 1. Build a new codeTable entry string
                            # consisting of a compile() function call with
                            # the first compile() argument consisting of
                            # the string returned by the fixdelimiters call
                            # above. Note that fixdelimiters() puts the
                            # appropriate " OR ' around the string it
                            # returns -- see def fixdelimiters() elsewhere in
                            # this file -- so you can just concatenate the
                            # string returned by fixdelimiters into the
                            # compile string without adding extra ' OR "
                            # chars around it. Use 'nofile' for the second
                            # argument to compile, and use a third argument
                            # appropriate for an eval expression.
                            # 2. Append this codeTable entry string into
                            # codeTable as defined in STUDENT 1, noting
                            # the numeric index of this new entry.
                            # 3. Emit code -- 
                            #   objfile.write(prefix + "        if " ETC.
                            # that calls eval() on the eventual __codeTable__
                            # entry compiled into the generated objfile,
                            # instead of calling eval() on the Python
                            # expression string. See test343SLOW.py.dif.txt.
                            # Keep the globals,locals arguments as they are;
                            # they supply the global & local variable
                            # bindings for evaluating the expression.
                            # All prefix and deepfix strings apply to the
                            # generated eval statement, not to the generated
                            # compile statement in the __codeTable__.
                            # KEEP THE LINES BELOW AS THEY ARE.

                            deepfix = prefix + "            "
                        else:
                            deepfix = prefix + "        "
                        tostate = sm.states[xt.destState]
                        if (not xt.activity) and (not tostate.isaccept):
                            horror(ValueError,
                                ("State machine " + smname + ", state " \
                                    + sname + " has a transition with no "  \
                                    + "activity."))
                        if (not xt.activity) and tostate.isaccept:
                            acts = []
                        else:
                            acts = xt.activity.split(";")
                        cleanacts = []
                        for dirtyact in acts:
                            stripped = dirtyact.strip()
                            if len(stripped) and stripped[0] == '#':
                                horror(ValueError,
                                    ("State machine " + smname + ", state " \
                                      + sname                               \
                                      + " has a comment embedded in a"      \
                                      + " command: " + stripped             \
                                      + ".\nA comment must go on its own line."))
                            if stripped != '':
                                cleanacts.append(dirtyact);
                        acts = cleanacts
                        lastacts = copy.copy(acts)
                        blockingAct4sm = lastact['thread']          \
                            if smname == 'thread' else          \
                                (lastact['processor']           \
                                    if smname == 'processor'    \
                                        else lastact['subgraph'])
                        if not tostate.isaccept:
                            # There must be some kind of way out of here!
                            lastdance = lastacts[-1].strip()
                            mset = set([])
                            while lastdance in sm.macros:
                                if lastdance in mset:
                                    horror(ValueError,
                                        "CSC343Compile recursive invocation "
                                          + "of macro "
                                          + lastdance + " in set of of macros "
                                          + str(mset) + ".")
                                else:
                                    mset.add(lastdance)
                                lastacts = sm.macros[lastdance].split(';')
                                lastdance = lastacts[-1].strip()
                            # Find the name of the function call/continuation.
                            findspace = lastdance.find(' ')
                            if findspace > -1:
                                lastdance = lastdance[:findspace]
                            findspace = lastdance.find('(')
                            if findspace > -1:
                                lastdance = lastdance[:findspace]
                            else:
                                horror(ValueError,
                                  ("The final action on "  \
                                        + "transition in " \
                                        + "machine " + smname   \
                                        + ", from state "   \
                                        + sname + " to state "  \
                                        + xt.destState \
                                        + " appears not to be a function CALL "\
                                        + " from " + str(blockingAct4sm) \
                                        + ": " + lastdance + '\n'))
                            lastdance = clean(lastdance)
                            if not lastdance in blockingAct4sm:
                                horror(ValueError,
                                  ("The final action on every non-accept "  \
                                        + "transition in " \
                                        + "machine " + smname   \
                                        + ", from state "   \
                                        + sname + " to state "  \
                                        + xt.destState  \
                                        + " must be a blocking action "\
                                        + " from " + str(blockingAct4sm) \
                                        + ": " + lastdance + '\n'))
                            elif lastdance != 'trigger'             \
                                    and lastdance != 'waitForEvent':
                                isgoingSomewhere = False
                                for laterTrans in tostate.transitions:
                                    if laterTrans.event == lastdance:
                                        isgoingSomewhere = True
                                        break
                                if not isgoingSomewhere:
                                    horror(ValueError,
                                      ("The final action " + lastdance  \
                                            + " in machine " + smname   \
                                            + ", from state "   \
                                            + sname + " to state "  \
                                            + xt.destState  \
                                            + " has no matching event from " \
                                            + xt.destState + ".\n"))
                        delayedArrive = False
                        if xt.sourceState == xt.destState:
                            objfile.write(deepfix           \
                                + 'self.logger.log(self, tag="REPEAT")\n')
                        else:
                            objfile.write(deepfix           \
                                + 'self.logger.log(self, tag="DEPART")\n')
                            objfile.write(deepfix + "self.state = '"        \
                                + xt.destState + "'\n")
                            # DEBUG 9/4/2015 objfile.write(deepfix           \
                                # DEBUG 9/4/2015 + 'self.logger.log(self, tag="ARRIVE")\n')
                            objfile.write(deepfix           \
                                + 'self.logger.log(self, tag="APPROACH")\n')
                            delayedArrive = True
                        genacts(sm, None, set([]), acts, objfile, deepfix,
                            sname, xt.destState, blockingAct4sm, delayedArrive)
                    if state.transitions:
                        # Added 10/19/2014 to warn without an error
                        objfile.write(prefix
                            + "    if event != __lastMissedEvent__ and "
                            + "self.logger.getLevel() >= (__DEBUGLEVEL__-1):\n")
                        objfile.write(prefix + "        "
                            + 'self.msg("INFO: Missed event: " + event + " From state: " + self.state)\n')
                        objfile.write(prefix
                            + "        __lastMissedEvent__ = event\n")
        def genacts(sm, macroname, macroset, acts, objfile, deepfix,
                srcStateName, destStateName, blockingAct4sm, prependLogToYield):
            if macroname:
                if macroname in macroset:
                    horror(ValueError,
                        "CSC343Compile recursive invocation of macro "
                        + macroname + " in set of of macros " + str(macroset)
                            + ".")
                macroset = copy.copy(macroset)  # Do not mutate incoming param.
                macroset.add(macroname)
            actindex = 0
            fixacts = []
            for aa in acts:     # Added 9/4/2015
                aaa = clean(aa)
                if aaa:
                    fixacts.append(aaa)
            acts = fixacts
            for aa in acts:
                actindex += 1
                aaa = clean(aa)
                if not aaa:
                    continue
                elif  aaa in sm.macros:
                    genacts(sm, aaa, macroset, sm.macros[aaa].split(';'),
                        objfile, deepfix, srcStateName, destStateName,
                            blockingAct4sm,
                            (prependLogToYield and (actindex == len(acts))))
                else:
                    __codeTable__.append("compile(" + fixdelimiters(aaa)    \
                        + ",'nofile','exec')")
                    objfile.write(deepfix + "exec(__codeTable__["   \
                        + str(len(__codeTable__)-1) + "],"          \
                        + "globals,locals)\n")
                    #objfile.write(deepfix +
                    #    "exec(" + fixdelimiters(aaa)
                    #        + ",globals,locals)\n")
                    
                    # STUDENT 3: This "else:" section is the
                    # block of code that generates code for STM
                    # exec statements. We use exec instead
                    # of eval because these are any form of Python
                    # statement. My solution comments
                    # out the above 3 lines of code in this "else"
                    # block (keep "else:" as it is), replacing
                    # them with the following logic:
                    # 1. Build a new codeTable entry string
                    # consisting of a compile() function call with
                    # the first compile() argument consisting of
                    # the string returned by the fixdelimiters call
                    # above. See STUDENT 2 comments for details.
                    # Use 'nofile' for the second
                    # argument to compile, and use a third argument
                    # appropriate for an exec statement that can compile
                    # one Python statement, or multiple statements
                    # separated by the ";" or other forms of compound
                    # statements.
                    # 2. Append this codeTable entry string into
                    # codeTable as defined in STUDENT 1, noting
                    # the numeric index of this new entry.
                    # 3. Emit code -- 
                    #   objfile.write(deepfix + ETC.
                    # that calls exec() on the eventual __codeTable__
                    # entry compiled into the generated objfile,
                    # instead of calling exec() on the Python
                    # expression string. See test343SLOW.py.dif.txt.
                    # Keep the globals,locals arguments as they are;
                    # they supply the global & local variable
                    # bindings for executing the statement(s).
                    # All prefix and deepfix strings apply to the
                    # generated exec statement, not to the generated
                    # compile statement in the __codeTable__.
                    # KEEP THE LINES BELOW AS THEY ARE. They are in this
                    # "else:" block.

                    # Find the name of the function call/continuation.
                    funcname = aaa
                    findspace = funcname.find(' ')
                    if findspace > -1:
                        funcname = funcname[:findspace]
                    findspace = funcname.find('(')
                    if findspace > -1:
                        funcname = funcname[:findspace]
                    if funcname in blockingAct4sm: # Added 8/2014 for generator
                        if (prependLogToYield and (actindex == len(acts))):
                            # ARRIVE moved here 9/4/2015
                            objfile.write(deepfix           \
                                + 'self.logger.log(self, tag="ARRIVE")\n')
                            prependLogToYield = False
                        elif (actindex < len(acts)):
                            sys.stderr.write('INFO: Blocking function '
                                + funcname + ' is in mid-transition from '
                                + sm.name + '.' +  srcStateName + " -> "
                                + destStateName + ', so its completion event '
                                + "will not trigger a state change.\n")
                        objfile.write(deepfix + "yield None\n")
            if prependLogToYield:
                # ARRIVE moved here 9/4/2015, for non-blocking trans into accept
                objfile.write(deepfix           \
                    + 'self.logger.log(self, tag="ARRIVE")\n')
                prependLogToYield = False
            dstst = sm.states[destStateName]
            if dstst.issubgraph and not macroname:
                objfile.write(deepfix
                    + "if not isinstance(self.thread, _Thread_):\n"
                    + deepfix
                    + "    raise ValueError('ERROR: Subgraphs callable only "
                    + "from STM thread at this time.')\n")
                objfile.write(deepfix + "__subgraph__ = "
                    + destStateName + "('" + destStateName
                    + "',self,self.processor,self.thread,self.__sleepResult__)\n")
                objfile.write(deepfix + "# DEPRECATED __subgraph__.run()\n")
                objfile.write(deepfix + "self.scheduler.sleep(0,__subgraph__,"
                    + "'init',self.__sleepResult__[2])\n")
                objfile.write(deepfix + "yield None\n")
                objfile.write(deepfix + "__subgraph__ = None\n")
            if not macroname:
                objfile.write(deepfix + "__lastMissedEvent__ = None\n")
                objfile.write(deepfix + "continue\n")
        # Main body of code for function generate().
        suppliedmachines = set(symtab.keys())
        if not 'processor' in suppliedmachines:
            horror(ValueError,
              "CSC343Compile state machine 'processor', not found.")
        if not 'thread' in suppliedmachines:
            horror(ValueError,
              "CSC343Compile state machine 'thread', not found.")
        if symtab['processor'].startstate.name != 'init':
            horror(ValueError,
                ("processor start state must be called 'init', not "        \
                    + symtab['processor'].startstate.name))
        if symtab['thread'].startstate.name != 'init':
            horror(ValueError,
                ("thread start state must be called 'init', not "        \
                    + symtab['thread'].startstate.name))
        if parseTree[1] != 'processor':
            horror(ValueError,
              "CSC343Compile require 'processor' as initial state machine, " \
                + "found: '" + str(parseTree[1]) + "'.")
        tmplfile = None
        tryme = \
          '/home/KUTZTOWN/parson/OpSys/state2codeV15/CSC343.template.txt'
        try:
            tmplfile = open('CSC343.template.txt', 'rU')
        except IOError, msg:
            try:
                tmplfile = open(tryme)
            except IOError:
                sys.stderr.write("Cannot open file 'CSC343.template.txt' or '" \
                    + tryme + "'\n")
                raise
        line = tmplfile.readline()
        while line and not line.strip().startswith('#<<<<<PROCESSOR_GLOBALS'):
            objfile.write(line)
            line = tmplfile.readline()
        if not (line and line.strip().startswith('#<<<<<PROCESSOR_GLOBALS')):
            horror(ValueError,
              "CSC343Compile INTERNAL ERROR, missing #<<<<<PROCESSOR_GLOBALS")
        depth = line.find('#')
        prefix = line[0:depth]
        genvars('processor', symtab['processor'], prefix, objfile)
        line = tmplfile.readline()
        objfile.write(line)     # emit the line with the closing }
        objfile.write(prefix[0:-4] + 'self.__eventSet__ = '
            + repr(symtab['processor'].eventSet) + '\n')
        line = tmplfile.readline()
        while line and not line.strip().startswith('#<<<<<PROCESSOR_RUN'):
            objfile.write(line)
            line = tmplfile.readline()
        if not (line and line.strip().startswith('#<<<<<PROCESSOR_RUN')):
            horror(ValueError,
              "CSC343Compile INTERNAL ERROR, missing #<<<<<PROCESSOR_RUN")
        depth = line.find('#')
        prefix = line[0:depth]
        genrun('processor', symtab['processor'], prefix, objfile)
        line = tmplfile.readline()
        while line and not line.strip().startswith('#<<<<<THREAD_GLOBALS'):
            objfile.write(line)
            line = tmplfile.readline()
        if not (line and line.strip().startswith('#<<<<<THREAD_GLOBALS')):
            horror(ValueError,
              "CSC343Compile INTERNAL ERROR, missing #<<<<<THREAD_GLOBALS")
        depth = line.find('#')
        prefix = line[0:depth]
        genvars('thread', symtab['thread'], prefix, objfile)
        line = tmplfile.readline()
        objfile.write(line)     # emit the line with the closing }
        objfile.write(prefix[0:-4] + 'self.__eventSet__ = '
            + repr(symtab['thread'].eventSet) + '\n')
        line = tmplfile.readline()
        while line and not line.strip().startswith('#<<<<<THREAD_RUN'):
            objfile.write(line)
            line = tmplfile.readline()
        if not (line and line.strip().startswith('#<<<<<THREAD_RUN')):
            horror(ValueError,
              "CSC343Compile INTERNAL ERROR, missing #<<<<<THREAD_RUN")
        depth = line.find('#')
        prefix = line[0:depth]
        genrun('thread', symtab['thread'], prefix, objfile)
        line = tmplfile.readline()
        while line:
            objfile.write(line)
            line = tmplfile.readline()
        tmplfile.close()
        prefix = '        '     # for subgraph classes
        for smname in suppliedmachines:
            if smname in ['processor', 'thread']:
                continue
            objfile.write('class ' + smname + '(_SubGraph_):\n')
            objfile.write(__SubGraph_Template_Head__)
            objfile.write(prefix + 'self.__eventSet__.update('
                + repr(symtab[smname].eventSet) + ')\n')
            objfile.write(prefix + 'locals = {\n')
            genvars(smname, symtab[smname], prefix + '    ', objfile)
            objfile.write(prefix + '}\n')
            objfile.write(prefix + 'self.locals = locals')
            objfile.write('''
        self.__localnames__ = locals.keys()
        self.__localcount__ = len(self.__localnames__)
        if isinstance(self.pcb, PCB):
            self.__pcbnames__ = self.pcb.__dict__.keys()
            self.__pcbcount__ = len(self.__pcbnames__)
        else:
            self.__pcbnames__ = []
            self.__pcbcount__ = 0
        if isinstance(self.processor, __scheduledObject__):
            self.__processornames__ = self.processor.__dict__.keys()
            self.__processorcount__ = len(self.__processornames__)
        else:
            self.__processornames__ = []
            self.__processorcount__ = 0
        self.__objnames__ = None        # Need these 2 in the __dict__.
        self.__objcount__ = -1
        self.__objnames__ = self.__dict__.keys()
        self.__objcount__ = len(self.__objnames__)\n''')
            objfile.write(prefix + 'try:\n')
            prefix = prefix + '    '
            objfile.write(prefix + 'try:\n')
            prefix = prefix + '    '
            objfile.write(prefix + "__laststate__ = 'init'\n");
            objfile.write(prefix + '''while not self.__isdead__:
                    if __laststate__ == 'init':
                        self.__localnames__ = locals.keys()
                        self.__localcount__ = len(self.__localnames__)
                        self.__objnames__ = self.__dict__.keys()
                        self.__objcount__ = len(self.__objnames__)
                    elif len(locals.keys()) != self.__localcount__:
                        errthing = "Assignment to undeclared variable(s):"
                        for k in locals.keys():
                            if not k in self.__localnames__:
                                errthing = errthing + " " + k
                        errthing = errthing + " in subgraph STM."
                        errthing = (errthing + ". Initialization must occur in "
                            + "a variable declaration or init -> transition.")
                        raise AttributeError(errthing)
                    elif len(self.__dict__.keys()) != self.__objcount__:
                      errthing = "Assignment to undeclared subgraph field(s):"
                      for k in self.__dict__.keys():
                        if not k in self.__objnames__:
                            errthing = errthing + " " + k
                      errthing = errthing + " in subgraph STM."
                      errthing = (errthing + ". Initialization must occur in "
                            + "an init -> transition.")
                      raise AttributeError(errthing)
                    if (isinstance(self.pcb, PCB) and len(self.pcb.__dict__.keys()) != self.__pcbcount__):
                      errthing = "Assignment to undeclared pcb field(s):"
                      for k in self.pcb.__dict__.keys():
                            if not k in self.__pcbnames__:
                                errthing = errthing + " " + k
                      errthing = (errthing + " in subgraph "
                        + str(self.graphname) + ".")
                      errthing = (errthing + " Initialization must occur in "
                            + "thread 0 before spawning other threads.")
                      raise AttributeError(errthing)
                    if (isinstance(self.processor, __scheduledObject__) and len(self.processor.__dict__.keys())
                            != self.__processorcount__):
                      errthing = "Assignment to undeclared processor field(s):"
                      errthing = (errthing + ". Initialization must occur in "
                            + "the processor object's init -> transition.")
                      for k in self.processor.__dict__.keys():
                            if not k in self.__processornames__:
                                errthing = errthing + " " + k
                      errthing = (errthing + " disallowed in subgraph "
                        + str(self.graphname) + " STM.")
                      raise AttributeError(errthing)
                    __laststate__ = self.state
                    self.exclusiveWait = False
                    if self.__sleepResult__:
                        stime, event, args = self.__sleepResult__
                        # DEPRECATED self.logger.log(self)
                    else:
                        stime = self.scheduler.time
                        event = None
                        args = None\n''')
            genrun(smname, symtab[smname], prefix + '    ', objfile)
            #objfile.write(__SubGraph_Template_Tail__)
        objfile.write('__codeTable__ = [\n')
        for i in range(len(__codeTable__)):
            objfile.write('    ' + __codeTable__[i] + ',\n')
        objfile.write('    ' + 'None' + '\n')
        objfile.write(']\n')
        # STUDENT 4: Emit the contents of the codeTable as a module-global
        # list variable called __codeTable__, with the following statement
        # as the first:
        #   objfile.write('__codeTable__ = [\n')
        # and the subsequent lines generating the comma-separated entries
        # from codeTable of STUDENT 1. Each entry must be indented 4 spaces,
        # and the closing "]" is indented 0. See test343SLOW.py.dif.txt at the
        # bottom. Note from inspecting test343SLOW.py.dif.txt that I generated
        # an extra None entry with a following comma after completing the
        # loop that generates the codeTable entries; I did it to simplify
        # the generator for loop, and also to put a guard in, in case there
        # is an off-by-1 error somewhere; instead of stepping off of the
        # __codeTable__ array, generated code would try to eval or exec a
        # None in that case, instead of going past the __codeTable__ array.
        # It probably isn't needed, but it is needed to avoid a diff on
        # the generated code. This generation must go before the existing
        # __main__ generation, and it goes at the same indentation, i.e.,
        # objfile.write('__codeTable__ = [\n') at no indentation, and the
        # entry compile strings 1-per-line, indepnted by 4 spaces; the
        # closing "]" is not indented.
        # KEEP THE LINES BELOW AS THEY ARE.

        objfile.write('if __name__ == "__main__":\n')
        objfile.write('    main()\n')
        objfile.close()

# __SubGraph_Template_Head__ and __SubGraph_Template_Tail__
# have the non-generated parts for each _SubGraph_-derived class.
# They do not have the class declaration at the start, nor
# do they have the STM run() code. There may be multiple subgraph classes
# in a STM file. The subgraph run method logs any exception, then re-raises
# it for its calling thread or processor active object to handle.
__SubGraph_Template_Head__ = '''
    def __init__(self,graphname,caller,processor,thread,__sleepResult__):
        _SubGraph_.__init__(self,graphname,caller,processor,thread,
            __sleepResult__)
        self.__generator__ = self.run()
    def run(self):
        __lastMissedEvent__ = None
        globals = {
            'math'      :   math,                   # module
            'functools' :   functools,              # module
            'operator'  :   operator,               # module
            'fork'      :   self.fork,              # method
            'spawn'     :   self.spawn,             # method
            'retire'    :   self.retire,            # method
            'wait'      :   self.wait,              # method
            'exit'      :   self.exit,              # method
            'kill'      :   self.kill,              # method
            'join'      :   self.join,              # method
            'cpu'       :   self.cpu,               # method
            'io'        :   self.io,                # method
            'sleep'     :   self.sleep,             # method
            'yieldcpu'  :   self.yieldcpu,          # method
            'trigger'   :   self.trigger,           # method
            'sample'    :   self.sample,            # method
            'time'      :   self.time,              # method
            'getid'     :   self.getid,             # method
            'waitForEvent' : self.waitForEvent,     # method
            'signalEvent' : __scheduledObject__.signalEvent,       # method
            'assign'    :   self.assign,            # method
            'noop'      : __scheduledObject__.noop,       # method
            'msg'       :   self.msg,               # method
            "pcb"       :   self.pcb,               # field
            'processor' :   self.processor,         # field
            'thread'    :   self,                   # this object
            'Queue'     :   Queue,                  # class
            'self'      :   self                    # this object
        }
        self.globals = globals
'''
__SubGraph_Template_Tail__ = '''
            except __ThreadRetireException__, ignoreme:
                # The retire() method notifies top level.
                self.__sleepResult__ = (self.scheduler.time, 'retire', None)
            except Exception, xxx:
                self.__sleepResult__ = (self.scheduler.time, 'ERROR', None)
                if self.logger.isOpen():
                    self.logger.log(self)
                    self.state = "<defunct subgraph " + str(self) + " on Exception " + str(xxx) + ">"
                    self.logger.log(self)
                    traceback.print_exc(file=self.logger.getFile())
                    self.logger.flush()
                raise
        finally:
            self.scheduler.sleep(0,self.caller,self.__sleepResult__[1],
                self.__sleepResult__[2])
'''
