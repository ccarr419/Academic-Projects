# CSC 343, Fall 2016. D. Parson, assignment 1.
# STUDENT: Christian Carreras
# ABOUT: This program simulates a state machine that depicts the prisoners'
# dilemma. There are two prisoners who will either cooperate or defect. Based
# upon both their choices a jail sentence will be chosen and the computer
# will schedule cpu until that sentence is carried out. The prisoners' choices
# will be decided using four methods. The methods include cooperate: which will
# always cooperate, defect: which will always defect, halfsy: which will use
# a sampler to randomly choose one of the choices, and reciprocate: which will
# initially cooperate for the first move then will copy the partner's
# previous move.

machine processor {
    # STUDENT: Do not change the processor state machine.
    # Use this machine in all of your files in assignment 1 to start thread
    # state machines, in which each one of 10 is a 2-threaded process.
    # Each field in object processor is visible to all thread state machines.
    # Below is a table action[pid][tid] that is indexed on each thread's
    # [processID][threadID] according to the actions defined below:
    #   "defect" always sends the "defect" message to its partner thread.
    #   "cooperate" always sends the "cooperate" message to its partner thread.
    #   "halfsy" uses sample(0,1,'uniform') each time to decide whether
    #       to send "defect" for a sample of 0, "cooperate" for a 1.
    #   "reciprocate" sends "cooperate" on its initial message, and then
    #       echoes its partner's most recent previous message of
    #       "defect" or "cooperate" on its next message.
    # Use the @@ delimiters around non-numeric Python data types.
    # Using @@ passes the source code directly to Python.
    # Use matching "doble quotes" to delimit strings.
    # Use "and" or "or" instead of "&&" or "||" in boolean guard expressions.
    processesToGo = 10, tid = -1, pid = -1;
    start init, state makingProcesses, accept processorDone ;
    init -> makingProcesses init()[]/@
        # See above, processor.action indexed on [pid][tid], i.e.,
        # processor.action[pid][tid] gives a thread object's strategy.
        # Comments for processor.penalty are after its code.
        processor.action = [
            ["defect", "defect"],
            ["defect", "cooperate"],
            ["defect", "halfsy"],
            ["defect", "reciprocate"],
            ["halfsy", "cooperate"],
            ["reciprocate", "cooperate"],
            ["cooperate", "cooperate"],
            ["halfsy", "halfsy"],
            ["halfsy", "reciprocate"],
            ["reciprocate", "reciprocate"]
        ];
        processor.penalty = {
            "defect" : {
                "defect" : 2,
                "cooperate" : 0
            },
            "cooperate" : {
                "defect" : 3,
                "cooperate" : 1
            }
        };
        # penalty is a 2D associative array (indexed using strings),
        # in which the the first index gives my current action,
        # the second index gives my partner's, and the result of
        # indexing gives my penalty in this round. For example,
        # processor.penalty["cooperate"]["defect"] has a value of 3.
        # See https://en.wikipedia.org/wiki/Prisoner%27s_dilemma
        #
        # processorSampling is used when a halfsy thread calls sample(),
        # mapping 0 to defect and 1 to cooperate.
        processor.processorSampling = ["defect", "cooperate"];
        # Start process 0, thread 0, then continue:
        processesToGo -= 1 ; fork()@
    makingProcesses -> makingProcesses fork(pid, tid)[@processesToGo > 0@]/@
        processesToGo -= 1 ; fork()@
    makingProcesses -> processorDone fork(pid, tid)[@processesToGo == 0@]/
}

# STUDENT work goes into machine thread according to the handout.
# Add documentation comments for the code that you write!!!
machine thread {
    # You WILL need to create additional variables.
    # For example, strategy "reciprocate" needs to keep track of
    # its partner's most recent action. Each thread STM must keep track
    # of its partner's most recent action, as just noted, and its own
    # most recent action, when computing a penalty for a move in the game.
    # When the iterations to the transition to go into the terminated state
    # increment loopCount to >= loopLimit, go to terminated.
	partnersLastAction = "cooperate",
    othertid = -1, loopCount = 0, loopLimit = 100, myLastAction = "cooperate",
        SendRecvAction = "SendRecvActionBUG";
    start init, state initThread, state sendMyAction,
        state awaitOtherAction, state timeInJail, accept terminated ;
    # Macro SendRecvSync sends message in SendRecvAction to its partner,
    # where variable SendRecvAction holds one of "defect" or "cooperate".
    # A transition must assign to SendRecvAction before invoking SendRecvSync.
    # After sending, a thread waits to receive its own receiveOtherAction
    # from its partner unless the partner has already deposited the message
    # into pcb.incomingMessage[tid].
    # Invoke SendRecvSync by saying SendRecvSync without a trailing semicolon.
    # You do not need a semicolon on any final action.
    macro SendRecvSync @
        pcb.incomingMessage[othertid] = SendRecvAction ;
        signalEvent(pcb.partners[othertid], "receiveOtherAction",
            SendRecvAction);
        waitForEvent('receiveOtherAction', False)
                if not pcb.incomingMessage[tid]
            else trigger(0, 'receiveOtherAction', pcb.incomingMessage[tid])
        @
    init -> initThread init()[]/@
        machineID, pid, tid = getid();
        msg("Example DEBUG message, pid = " + str(pid) + " tid = " + str(tid));
        # mystrategy is one of the 4 string values in processor.action.
        # State machine variables persist across all transitions once set.
        mystrategy = processor.action[pid][tid];
        cpu(0)@
    initThread -> sendMyAction cpu()[@tid == 0@]/@
        # Next two threads are indexed on tids 0 and 1.
        # pcb.partners holds a pointer to the thread objects.
        # pcb.incomingMessage holds message from its partner or "" or None.
        # pcb is the Process Control Block (PCB) object. A PCB holds data
        # shared by all threads in a process. It emulates a process' memory.
        # None is Python's NULL pointer.
        pcb.partners = [thread, None];
        pcb.incomingMessage = ["", ""];
        othertid = 1;
        spawn();
        # Give tid 1 time to populate pcb.partners[1]
        cpu(10)@
    initThread -> sendMyAction cpu()[@tid == 1@]/@
        pcb.partners[1] = thread;
        othertid = 0;
        cpu(0);@
    # STUDENT: CREATE TRANSITIONS TO state awaitOtherAction, timeInJail,
    # terminated, and back to sendMyAction as indicated by the handout.
    # The final two actions in any transition to awaitOtherAction MUST BE
    # assignment of "defect" or "cooperate" into variable SendRecvAction,
    # and then SendRecvSync with no trailing semicolon. the initial action
    # from state awaitOtherAction to timeInJail MUST BE 
    # pcb.incomingMessage[tid] = None; in order to clear that message buffer.
	
	#This transition occurs when the prisoner's strategy is 'cooperate' or 'defect'.
	#The name of the strategy is assigned to the current thread's last action as
	#the strategies have the same name as the action. The action is then sent
	#as a message to the parter thread by using the macro SendRecvSync.
    sendMyAction -> awaitOtherAction cpu()[@mystrategy == "cooperate" or mystrategy == "defect"@]/@
		myLastAction = mystrategy;
		SendRecvAction = myLastAction;
		SendRecvSync@
	
	#This transition occurs when the thread's strategy is 'halfsy'. The action
	#is chosen at random by the use of the sample function. If the
	#sample returns 0 then the action will be 'defect' and if the sample returns
	#1 the action will be 'cooperate'. Thus the name 'halsy' signifies that
	#both actions should be chosen approximately half the time. The action is
	#then sent as a message to the partner thread by using the macro SendRecvSync.
	sendMyAction -> awaitOtherAction cpu()[@mystrategy == "halfsy"@]/@
		myLastAction = processor.processorSampling[sample(0, 1, 'uniform')];
		SendRecvAction = myLastAction;
		SendRecvSync@
	
	#This transition occurs when the thread's strategy is 'reciprocate'.
	#The goal of this strategy is to choose the same action that the parter
	#picked last time. So if the partner picked 'defect' last round, 'defect'
	#will be picked for this round. Likewise, 'cooperate' will be chosen if the
	#partner picked 'cooperate' last time. The action will then be sent as a 
	#message to the partner thread by using the macro SendRecvSync.
	sendMyAction -> awaitOtherAction cpu()[@mystrategy == "reciprocate"@]/@
		myLastAction = partnersLastAction;
		SendRecvAction = myLastAction;
		SendRecvSync@
    
	#This transition calculates the total amount of time (if any) the player
	#will spend in jail. The penalty will be processed from the players action
	#and the partner's action which was sent in the receiveOtherAction event.
	#The transition will schedule a cpu event for the penalty which
	#will be 0, 1, 2, or 3 depending on the choices of the prisoners.
	#The incomingMessage buffer is also cleared to avoid problems in
	#future iterations.
    awaitOtherAction -> timeInJail receiveOtherAction(partnersLastAction)[]/@
		pcb.incomingMessage[tid] = None;
		cpu(processor.penalty[myLastAction][partnersLastAction]);@
    
	#If the loop limit has not been reached, increment the loop counter variable
	#and go back to sendMyAction state so the game can be played again.
    timeInJail -> sendMyAction cpu()[@loopCount < loopLimit@]/@
		loopCount += 1;
		cpu(0);@
    
	#If the loop limit has been reached or exceeded, transition into the
	#terminated state to end the game for this thread.
    timeInJail -> terminated cpu()[@loopCount >= loopLimit@]/
}

processor
