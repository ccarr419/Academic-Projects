# D. Parson, test343.stm is test input for CSC343Compile.py
# test343multi.stm tests s1, s2, s3 -> * types of transitions
# Added some macro tests August 2, 2014.
# test343subgraph.stm adds push down automaton subgraphs to test343multi.stm,
# October 2014.

machine processor {
    a = 1, b = 2.3, c = 'string c', d = "string d",
        l = @[0, [1], (2,), {3 : 'three'}]@, pid = -1, tid = -1 ;
    start init, state afterstart, accept alldone ;
    init -> afterstart init()[]/@fork()@;
    afterstart -> alldone fork(pid, tid)[]/@
        msg("post-fork pid " + str(pid) + " tid " + str(tid));
        msg("post-fork test of local vars a " + str(a)
            + " b " + str(b) + " c " + c + " d " + str(d) + " l " + str(l))@;
}

machine thread {
    meals = 1 ;
    start init, state breakfast, subgraph lunch, state dinner,
        state snack, state acidreflux, accept gnight ;
    macro sample1 @ meals = sample(1,3,"uniform") @
    macro sample2 @ meals = sample(2,3,"uniform") @
    init -> breakfast init()[]/@ sample1 ;
        msg("breakfast consists of " + str(meals) + " meals");
        trigger(1, "eat")@
    breakfast, dinner -> * eat()[@meals > 0@]/@meals -= 1;
        trigger(1, "eat")@;
    # trigger at the bottom of the next transition passes
    # meals as a parameter into subgraph lunch.
    breakfast -> lunch eat()[@meals == 0@]/@sample1 ;
        msg("lunch consists of " + str(meals) + " meals");
        trigger(1, "eat", meals)@,
    # The lunch subgraph must pass 0 meals via the transition
    # to its accept state.
    lunch -> dinner eat(meals)[@meals == 0@]/@sample1 ;
        msg("dinner consists of " + str(meals) + " meals");
        trigger(1, "eat")@
    dinner -> snack eat()[@meals == 0@]/@sample2 ;
        msg("snack consists of " + str(meals) + " meals");
        trigger(1, "eat")@;
    snack -> snack eat()[@meals == 1@]/@meals -= 1;
        trigger(1, "eat")@;
    snack -> acidreflux eat()[@meals > 1@]/@meals -= 1;
        trigger(1, "eat")@;
    snack -> gnight eat()[@meals == 0@]/@msg("good night")@;
    acidreflux -> snack eat()[]/@trigger(1, "eat")@;
}

machine lunch {
    meals = 0 ;
    start init, state eating, accept done ;
    # See caller for passing meals parameter to init(meals) event.
    init -> eating init(meals)[]/@
        msg("lunch init -> eating " + str(meals));
        trigger(0, "eat")@
    eating -> eating eat() [@meals > 0@]/@meals -= 1;
        msg("lunch eating -> eating " + str(meals));
        trigger(1, "eat")@;
    # Pass 0 meals as return value on transition into accept state.
    eating -> done eat()[]/@
        msg("lunch eating -> done " + str(meals));
        trigger(0, "eat", 0)@
}

processor
